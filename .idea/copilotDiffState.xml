<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/activities/LoginActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/activities/LoginActivity.java" />
              <option name="originalContent" value="package com.sgionotes.activities;&#10;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.LinearLayout;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import com.google.android.material.snackbar.Snackbar;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.sgionotes.R;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import com.sgionotes.models.GenerarData;&#10;&#10;public class LoginActivity extends AppCompatActivity {&#10;&#10;    private Button btnLogin;&#10;    private TextView registerRedirect;&#10;    private EditText txtEmail;&#10;    private EditText txtPassword;&#10;    private LinearLayout loginMain;&#10;&#10;    private FirebaseAuth mAuth;&#10;    private FirestoreRepository firestoreRepository;&#10;    boolean registroExitoso;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_login);&#10;&#10;        // InicializarFirebaseAuth&#10;        mAuth = FirebaseAuth.getInstance();&#10;        firestoreRepository = new FirestoreRepository(this);&#10;&#10;        registroExitoso = getIntent().getBooleanExtra(&quot;registro_exitoso&quot;, false);&#10;&#10;        txtEmail = findViewById(R.id.txtEmail);&#10;        txtPassword = findViewById(R.id.txtPassword);&#10;        btnLogin = findViewById(R.id.btnLogin);&#10;        loginMain = findViewById(R.id.loginMain);&#10;&#10;        if (registroExitoso) {&#10;            Snackbar.make(loginMain, &quot;Cuenta creada. Inicia sesión con tus credenciales&quot;, Snackbar.LENGTH_LONG).show();&#10;        }&#10;&#10;        btnLogin.setOnClickListener(btn -&gt; {&#10;            String email = txtEmail.getText().toString().trim();&#10;            String password = txtPassword.getText().toString().trim();&#10;&#10;            if (email.isEmpty() || password.isEmpty()) {&#10;                Snackbar.make(loginMain, &quot;Completa los campos para acceder&quot;, Snackbar.LENGTH_LONG).show();&#10;                return;&#10;            }&#10;&#10;            //Loanding&#10;            btnLogin.setEnabled(false);&#10;            btnLogin.setText(&quot;Iniciando sesión...&quot;);&#10;&#10;            loginWithFirebase(email, password);&#10;        });&#10;&#10;        registerRedirect = findViewById(R.id.registerRedirect);&#10;        registerRedirect.setOnClickListener(reg -&gt; {&#10;            Intent intent = new Intent(LoginActivity.this, RegisterActivity.class);&#10;            intent.putExtra(&quot;app_startup&quot;, false); // Indicar que NO es startup de la app&#10;            startActivity(intent);&#10;            finish();&#10;        });&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.loginMain), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;&#10;    private void loginWithFirebase(String email, String password) {&#10;        // Limpiar cualquier sesión previa antes de hacer login&#10;        mAuth.signOut();&#10;&#10;        mAuth.signInWithEmailAndPassword(email, password)&#10;                .addOnCompleteListener(this, task -&gt; {&#10;                    if (task.isSuccessful()) {&#10;                        // Login exitoso - verificar que el usuario sea el correcto&#10;                        FirebaseUser user = mAuth.getCurrentUser();&#10;                        if (user != null &amp;&amp; user.getEmail() != null) {&#10;                            Log.d(&quot;LoginActivity&quot;, &quot;Usuario autenticado: &quot; + user.getEmail() + &quot; UID: &quot; + user.getUid());&#10;                            Snackbar.make(loginMain, &quot;Bienvenido &quot; + user.getEmail(), Snackbar.LENGTH_SHORT).show();&#10;                            loadUserDataAndNavigate();&#10;                        } else {&#10;                            // Error en la obtención del usuario&#10;                            Snackbar.make(loginMain, &quot;Error en la autenticación&quot;, Snackbar.LENGTH_SHORT).show();&#10;                            resetLoginButton();&#10;                        }&#10;                    } else {&#10;                        // Login fallido&#10;                        Snackbar.make(loginMain, &quot;Usuario y/o contraseña inválidos&quot;, Snackbar.LENGTH_SHORT).show();&#10;                        resetLoginButton();&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void loadUserDataAndNavigate() {&#10;        // Reducir timeout a 3 segundos para mejor experiencia&#10;        android.os.Handler timeoutHandler = new android.os.Handler();&#10;        final boolean[] navigationCompleted = {false};&#10;&#10;        // Timeout de 3 segundos como respaldo&#10;        timeoutHandler.postDelayed(() -&gt; {&#10;            if (!navigationCompleted[0]) {&#10;                navigationCompleted[0] = true;&#10;                navigateToMainActivity();&#10;            }&#10;        }, 3000);&#10;&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        generarData.initializeWithContext(this);&#10;&#10;        // Crear datos por defecto y esperar a que se complete antes de navegar&#10;        generarData.createDefaultDataIfEmptyWithCallback(new GenerarData.DataInitializationCallback() {&#10;            @Override&#10;            public void onInitializationComplete() {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onInitializationError(String error) {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    // Si hay error en la inicialización, aún así navegar pero mostrar error&#10;                    Snackbar.make(loginMain, &quot;Error al cargar datos iniciales&quot;, Snackbar.LENGTH_SHORT).show();&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void resetLoginButton() {&#10;        btnLogin.setEnabled(true);&#10;        btnLogin.setText(&quot;Iniciar Sesión&quot;);&#10;    }&#10;&#10;    private void navigateToMainActivity() {&#10;        Intent intent = new Intent(LoginActivity.this, MainActivity.class);&#10;        startActivity(intent);&#10;        finish();&#10;    }&#10;&#10;    @Override&#10;    protected void onStart() {&#10;        super.onStart();&#10;        // Solo auto-login si la app se abre desde cero (no desde navegación entre activities)&#10;        // Y solo si no hay intención explícita de mostrar login&#10;        boolean isAppStartup = getIntent().getBooleanExtra(&quot;app_startup&quot;, true);&#10;        boolean fromRegister = getIntent().getBooleanExtra(&quot;registro_exitoso&quot;, false);&#10;&#10;        // No hacer auto-login si viene del registro o si el usuario explícitamente quiere hacer login&#10;        if (!fromRegister &amp;&amp; isAppStartup) {&#10;            FirebaseUser currentUser = mAuth.getCurrentUser();&#10;            if (currentUser != null) {&#10;                loadUserDataAndNavigate();&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.activities;&#10;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.LinearLayout;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import com.google.android.material.snackbar.Snackbar;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.sgionotes.R;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import com.sgionotes.models.GenerarData;&#10;&#10;public class LoginActivity extends AppCompatActivity {&#10;&#10;    private Button btnLogin;&#10;    private TextView registerRedirect;&#10;    private EditText txtEmail;&#10;    private EditText txtPassword;&#10;    private LinearLayout loginMain;&#10;&#10;    private FirebaseAuth mAuth;&#10;    private FirestoreRepository firestoreRepository;&#10;    boolean registroExitoso;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_login);&#10;&#10;        // InicializarFirebaseAuth&#10;        mAuth = FirebaseAuth.getInstance();&#10;        firestoreRepository = new FirestoreRepository(this);&#10;&#10;        registroExitoso = getIntent().getBooleanExtra(&quot;registro_exitoso&quot;, false);&#10;&#10;        txtEmail = findViewById(R.id.txtEmail);&#10;        txtPassword = findViewById(R.id.txtPassword);&#10;        btnLogin = findViewById(R.id.btnLogin);&#10;        loginMain = findViewById(R.id.loginMain);&#10;&#10;        if (registroExitoso) {&#10;            Snackbar.make(loginMain, &quot;Cuenta creada. Inicia sesión con tus credenciales&quot;, Snackbar.LENGTH_LONG).show();&#10;        }&#10;&#10;        btnLogin.setOnClickListener(btn -&gt; {&#10;            String email = txtEmail.getText().toString().trim();&#10;            String password = txtPassword.getText().toString().trim();&#10;&#10;            if (email.isEmpty() || password.isEmpty()) {&#10;                Snackbar.make(loginMain, &quot;Completa los campos para acceder&quot;, Snackbar.LENGTH_LONG).show();&#10;                return;&#10;            }&#10;&#10;            //Loanding&#10;            btnLogin.setEnabled(false);&#10;            btnLogin.setText(&quot;Iniciando sesión...&quot;);&#10;&#10;            loginWithFirebase(email, password);&#10;        });&#10;&#10;        registerRedirect = findViewById(R.id.registerRedirect);&#10;        registerRedirect.setOnClickListener(reg -&gt; {&#10;            Intent intent = new Intent(LoginActivity.this, RegisterActivity.class);&#10;            intent.putExtra(&quot;app_startup&quot;, false); // Indicar que NO es startup de la app&#10;            startActivity(intent);&#10;            finish();&#10;        });&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.loginMain), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;&#10;    private void loginWithFirebase(String email, String password) {&#10;        // Limpiar cualquier sesión previa antes de hacer login&#10;        mAuth.signOut();&#10;&#10;        mAuth.signInWithEmailAndPassword(email, password)&#10;                .addOnCompleteListener(this, task -&gt; {&#10;                    if (task.isSuccessful()) {&#10;                        // Login exitoso - verificar que el usuario sea el correcto&#10;                        FirebaseUser user = mAuth.getCurrentUser();&#10;                        if (user != null &amp;&amp; user.getEmail() != null) {&#10;                            Log.d(&quot;LoginActivity&quot;, &quot;Usuario autenticado: &quot; + user.getEmail() + &quot; UID: &quot; + user.getUid());&#10;                            Snackbar.make(loginMain, &quot;Bienvenido &quot; + user.getEmail(), Snackbar.LENGTH_SHORT).show();&#10;                            loadUserDataAndNavigate();&#10;                        } else {&#10;                            // Error en la obtención del usuario&#10;                            Snackbar.make(loginMain, &quot;Error en la autenticación&quot;, Snackbar.LENGTH_SHORT).show();&#10;                            resetLoginButton();&#10;                        }&#10;                    } else {&#10;                        // Login fallido&#10;                        Snackbar.make(loginMain, &quot;Usuario y/o contraseña inválidos&quot;, Snackbar.LENGTH_SHORT).show();&#10;                        resetLoginButton();&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void loadUserDataAndNavigate() {&#10;        // Reducir timeout a 1.5 segundos para login ultra rápido&#10;        android.os.Handler timeoutHandler = new android.os.Handler();&#10;        final boolean[] navigationCompleted = {false};&#10;&#10;        // Timeout de 1.5 segundos como respaldo&#10;        timeoutHandler.postDelayed(() -&gt; {&#10;            if (!navigationCompleted[0]) {&#10;                navigationCompleted[0] = true;&#10;                navigateToMainActivity();&#10;            }&#10;        }, 1500);&#10;&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        generarData.initializeWithContext(this);&#10;&#10;        // Crear datos por defecto y esperar a que se complete antes de navegar&#10;        generarData.createDefaultDataIfEmptyWithCallback(new GenerarData.DataInitializationCallback() {&#10;            @Override&#10;            public void onInitializationComplete() {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onInitializationError(String error) {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    // Si hay error en la inicialización, aún así navegar pero mostrar error&#10;                    Log.w(&quot;LoginActivity&quot;, &quot;Error de inicialización: &quot; + error);&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void resetLoginButton() {&#10;        btnLogin.setEnabled(true);&#10;        btnLogin.setText(&quot;Iniciar Sesión&quot;);&#10;    }&#10;&#10;    private void navigateToMainActivity() {&#10;        Intent intent = new Intent(LoginActivity.this, MainActivity.class);&#10;        startActivity(intent);&#10;        finish();&#10;    }&#10;&#10;    @Override&#10;    protected void onStart() {&#10;        super.onStart();&#10;        // Solo auto-login si la app se abre desde cero (no desde navegación entre activities)&#10;        // Y solo si no hay intención explícita de mostrar login&#10;        boolean isAppStartup = getIntent().getBooleanExtra(&quot;app_startup&quot;, true);&#10;        boolean fromRegister = getIntent().getBooleanExtra(&quot;registro_exitoso&quot;, false);&#10;&#10;        // No hacer auto-login si viene del registro o si el usuario explícitamente quiere hacer login&#10;        if (!fromRegister &amp;&amp; isAppStartup) {&#10;            FirebaseUser currentUser = mAuth.getCurrentUser();&#10;            if (currentUser != null) {&#10;                loadUserDataAndNavigate();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/activities/RegisterActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/activities/RegisterActivity.java" />
              <option name="originalContent" value="package com.sgionotes.activities;&#10;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.LinearLayout;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import com.google.android.material.snackbar.Snackbar;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.sgionotes.R;&#10;import com.sgionotes.models.UserProfile;&#10;import com.sgionotes.utils.UserProfileManager;&#10;&#10;import java.util.regex.Pattern;&#10;&#10;public class RegisterActivity extends AppCompatActivity {&#10;&#10;    private TextView txtLoginRedirect;&#10;    private EditText txtNombres;&#10;    private EditText txtApellidos;&#10;    private EditText txtCorreo;&#10;    private EditText txtPassword;&#10;    private LinearLayout registerMain;&#10;    private Button btnRegister;&#10;    private FirebaseAuth mAuth;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_register);&#10;&#10;        // InicializarFirebase&#10;        mAuth = FirebaseAuth.getInstance();&#10;&#10;        txtNombres = findViewById(R.id.txtNombres);&#10;        txtApellidos = findViewById(R.id.txtApellidos);&#10;        txtCorreo = findViewById(R.id.txtCorreo);&#10;        txtPassword = findViewById(R.id.txtPassword);&#10;        txtLoginRedirect = findViewById(R.id.loginRedirect);&#10;        registerMain = findViewById(R.id.registerMain);&#10;        btnRegister = findViewById(R.id.btnRegister);&#10;&#10;        txtLoginRedirect.setOnClickListener(btn -&gt; {&#10;            Intent intent = new Intent(RegisterActivity.this, LoginActivity.class);&#10;            intent.putExtra(&quot;app_startup&quot;, false); // Indicar que NO es startup de la app&#10;            startActivity(intent);&#10;            finish();&#10;        });&#10;&#10;        btnRegister.setOnClickListener(btn -&gt; {&#10;            if (validacionRegister()) {&#10;                // Mostrar loading&#10;                btnRegister.setEnabled(false);&#10;                btnRegister.setText(&quot;Creando cuenta...&quot;);&#10;&#10;                String email = txtCorreo.getText().toString().trim();&#10;                String password = txtPassword.getText().toString();&#10;&#10;                registerWithFirebase(email, password);&#10;            }&#10;        });&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.registerMain), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;&#10;    private void registerWithFirebase(String email, String password) {&#10;        // Limpiar cualquier sesión previa antes de registrar&#10;        mAuth.signOut();&#10;&#10;        mAuth.createUserWithEmailAndPassword(email, password)&#10;                .addOnCompleteListener(this, task -&gt; {&#10;                    if (task.isSuccessful()) {&#10;                        // Registro exitoso - verificar que el usuario sea el correcto&#10;                        FirebaseUser user = mAuth.getCurrentUser();&#10;                        if (user != null &amp;&amp; user.getEmail() != null) {&#10;                            Log.d(&quot;RegisterActivity&quot;, &quot;Usuario registrado: &quot; + user.getEmail() + &quot; UID: &quot; + user.getUid());&#10;                            saveUserProfile();&#10;                            Snackbar.make(registerMain, &quot;Cuenta creada exitosamente&quot;, Snackbar.LENGTH_SHORT).show();&#10;&#10;                            // Ir directamente a MainActivity después del registro exitoso&#10;                            loadUserDataAndNavigate();&#10;                        } else {&#10;                            // Error en la obtención del usuario&#10;                            Snackbar.make(registerMain, &quot;Error en el registro&quot;, Snackbar.LENGTH_SHORT).show();&#10;                            btnRegister.setEnabled(true);&#10;                            btnRegister.setText(&quot;Crear Cuenta&quot;);&#10;                        }&#10;                    } else {&#10;                        // Error en registro&#10;                        String errorMessage = &quot;Error al crear la cuenta&quot;;&#10;                        if (task.getException() != null) {&#10;                            String exception = task.getException().getMessage();&#10;                            if (exception != null &amp;&amp; exception.contains(&quot;email address is already in use&quot;)) {&#10;                                errorMessage = &quot;Este correo ya está registrado&quot;;&#10;                            } else if (exception != null &amp;&amp; exception.contains(&quot;weak password&quot;)) {&#10;                                errorMessage = &quot;La contraseña es muy débil&quot;;&#10;                            }&#10;                        }&#10;                        Snackbar.make(registerMain, errorMessage, Snackbar.LENGTH_LONG).show();&#10;                        btnRegister.setEnabled(true);&#10;                        btnRegister.setText(&quot;Crear Cuenta&quot;);&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void loadUserDataAndNavigate() {&#10;        // Reducir timeout a 3 segundos para mejor experiencia&#10;        android.os.Handler timeoutHandler = new android.os.Handler();&#10;        final boolean[] navigationCompleted = {false};&#10;&#10;        // Timeout de 3 segundos como respaldo&#10;        timeoutHandler.postDelayed(() -&gt; {&#10;            if (!navigationCompleted[0]) {&#10;                navigationCompleted[0] = true;&#10;                navigateToMainActivity();&#10;            }&#10;        }, 3000);&#10;&#10;        com.sgionotes.models.GenerarData generarData = com.sgionotes.models.GenerarData.getInstancia();&#10;        generarData.initializeWithContext(this);&#10;&#10;        // Crear datos por defecto y esperar a que se complete antes de navegar&#10;        generarData.createDefaultDataIfEmptyWithCallback(new com.sgionotes.models.GenerarData.DataInitializationCallback() {&#10;            @Override&#10;            public void onInitializationComplete() {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onInitializationError(String error) {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    // Mostrar error pero aún así navegar&#10;                    Snackbar.make(registerMain, &quot;Error al inicializar datos: &quot; + error, Snackbar.LENGTH_SHORT).show();&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void navigateToMainActivity() {&#10;        Intent intent = new Intent(RegisterActivity.this, com.sgionotes.activities.MainActivity.class);&#10;        startActivity(intent);&#10;        finish();&#10;    }&#10;&#10;    private void saveUserProfile() {&#10;        UserProfileManager profileManager = new UserProfileManager(this);&#10;&#10;        String nombres = txtNombres.getText().toString().trim();&#10;        String apellidos = txtApellidos.getText().toString().trim();&#10;        String email = txtCorreo.getText().toString().trim();&#10;        UserProfile profile = new UserProfile(nombres, apellidos, email, R.drawable.ic_person_24);&#10;        profileManager.saveUserProfile(profile);&#10;    }&#10;&#10;    private boolean validacionRegister() {&#10;&#10;        String nombres = txtNombres.getText().toString().trim();&#10;        String apellidos = txtApellidos.getText().toString().trim();&#10;        String correo = txtCorreo.getText().toString().trim();&#10;        String password = txtPassword.getText().toString();&#10;&#10;        if (nombres.isEmpty() || apellidos.isEmpty() || correo.isEmpty() || password.isEmpty()) {&#10;            Snackbar.make(registerMain, &quot;Todos los campos son obligatorios&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        if (nombres.length() &gt; 80 || apellidos.length() &gt; 80) {&#10;            Snackbar.make(registerMain, &quot;Nombres y apellidos deben tener máximo 80 caracteres&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        Pattern patternCorreo = Pattern.compile(&quot;^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$&quot;);&#10;        if (!patternCorreo.matcher(correo).matches()) {&#10;            Snackbar.make(registerMain, &quot;Correo no válido&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        if (password.length() &lt; 8 || password.length() &gt; 50) {&#10;            Snackbar.make(registerMain, &quot;La contraseña debe tener entre 8 y 50 caracteres&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        Pattern patternPassword = Pattern.compile(&quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&amp;*()_+\\-=\\[\\]{};':\&quot;\\\\|,.&lt;&gt;/?]).+$&quot;);&#10;        if (!patternPassword.matcher(password).matches()) {&#10;            Snackbar.make(registerMain, &quot;La contraseña debe tener mayúsculas, minúsculas, número y carácter especial&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        return true;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.sgionotes.activities;&#10;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.LinearLayout;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import com.google.android.material.snackbar.Snackbar;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.sgionotes.R;&#10;import com.sgionotes.models.UserProfile;&#10;import com.sgionotes.utils.UserProfileManager;&#10;&#10;import java.util.regex.Pattern;&#10;&#10;public class RegisterActivity extends AppCompatActivity {&#10;&#10;    private TextView txtLoginRedirect;&#10;    private EditText txtNombres;&#10;    private EditText txtApellidos;&#10;    private EditText txtCorreo;&#10;    private EditText txtPassword;&#10;    private LinearLayout registerMain;&#10;    private Button btnRegister;&#10;    private FirebaseAuth mAuth;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_register);&#10;&#10;        // InicializarFirebase&#10;        mAuth = FirebaseAuth.getInstance();&#10;&#10;        txtNombres = findViewById(R.id.txtNombres);&#10;        txtApellidos = findViewById(R.id.txtApellidos);&#10;        txtCorreo = findViewById(R.id.txtCorreo);&#10;        txtPassword = findViewById(R.id.txtPassword);&#10;        txtLoginRedirect = findViewById(R.id.loginRedirect);&#10;        registerMain = findViewById(R.id.registerMain);&#10;        btnRegister = findViewById(R.id.btnRegister);&#10;&#10;        txtLoginRedirect.setOnClickListener(btn -&gt; {&#10;            Intent intent = new Intent(RegisterActivity.this, LoginActivity.class);&#10;            intent.putExtra(&quot;app_startup&quot;, false); // Indicar que NO es startup de la app&#10;            startActivity(intent);&#10;            finish();&#10;        });&#10;&#10;        btnRegister.setOnClickListener(btn -&gt; {&#10;            if (validacionRegister()) {&#10;                // Mostrar loading&#10;                btnRegister.setEnabled(false);&#10;                btnRegister.setText(&quot;Creando cuenta...&quot;);&#10;&#10;                String email = txtCorreo.getText().toString().trim();&#10;                String password = txtPassword.getText().toString();&#10;&#10;                registerWithFirebase(email, password);&#10;            }&#10;        });&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.registerMain), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;&#10;    private void registerWithFirebase(String email, String password) {&#10;        // Limpiar cualquier sesión previa antes de registrar&#10;        mAuth.signOut();&#10;&#10;        mAuth.createUserWithEmailAndPassword(email, password)&#10;                .addOnCompleteListener(this, task -&gt; {&#10;                    if (task.isSuccessful()) {&#10;                        // Registro exitoso - verificar que el usuario sea el correcto&#10;                        FirebaseUser user = mAuth.getCurrentUser();&#10;                        if (user != null &amp;&amp; user.getEmail() != null) {&#10;                            Log.d(&quot;RegisterActivity&quot;, &quot;Usuario registrado: &quot; + user.getEmail() + &quot; UID: &quot; + user.getUid());&#10;                            saveUserProfile();&#10;                            Snackbar.make(registerMain, &quot;Cuenta creada exitosamente&quot;, Snackbar.LENGTH_SHORT).show();&#10;&#10;                            // Ir directamente a MainActivity después del registro exitoso&#10;                            loadUserDataAndNavigate();&#10;                        } else {&#10;                            // Error en la obtención del usuario&#10;                            Snackbar.make(registerMain, &quot;Error en el registro&quot;, Snackbar.LENGTH_SHORT).show();&#10;                            btnRegister.setEnabled(true);&#10;                            btnRegister.setText(&quot;Crear Cuenta&quot;);&#10;                        }&#10;                    } else {&#10;                        // Error en registro&#10;                        String errorMessage = &quot;Error al crear la cuenta&quot;;&#10;                        if (task.getException() != null) {&#10;                            String exception = task.getException().getMessage();&#10;                            if (exception != null &amp;&amp; exception.contains(&quot;email address is already in use&quot;)) {&#10;                                errorMessage = &quot;Este correo ya está registrado&quot;;&#10;                            } else if (exception != null &amp;&amp; exception.contains(&quot;weak password&quot;)) {&#10;                                errorMessage = &quot;La contraseña es muy débil&quot;;&#10;                            }&#10;                        }&#10;                        Snackbar.make(registerMain, errorMessage, Snackbar.LENGTH_LONG).show();&#10;                        btnRegister.setEnabled(true);&#10;                        btnRegister.setText(&quot;Crear Cuenta&quot;);&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void loadUserDataAndNavigate() {&#10;        // Reducir timeout a 1.5 segundos para registro ultra rápido&#10;        android.os.Handler timeoutHandler = new android.os.Handler();&#10;        final boolean[] navigationCompleted = {false};&#10;&#10;        // Timeout de 1.5 segundos como respaldo&#10;        timeoutHandler.postDelayed(() -&gt; {&#10;            if (!navigationCompleted[0]) {&#10;                navigationCompleted[0] = true;&#10;                navigateToMainActivity();&#10;            }&#10;        }, 1500);&#10;&#10;        com.sgionotes.models.GenerarData generarData = com.sgionotes.models.GenerarData.getInstancia();&#10;        generarData.initializeWithContext(this);&#10;&#10;        // Crear datos por defecto y esperar a que se complete antes de navegar&#10;        generarData.createDefaultDataIfEmptyWithCallback(new com.sgionotes.models.GenerarData.DataInitializationCallback() {&#10;            @Override&#10;            public void onInitializationComplete() {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onInitializationError(String error) {&#10;                if (!navigationCompleted[0]) {&#10;                    navigationCompleted[0] = true;&#10;                    timeoutHandler.removeCallbacksAndMessages(null);&#10;                    // Mostrar error pero aún así navegar&#10;                    Log.w(&quot;RegisterActivity&quot;, &quot;Error de inicialización: &quot; + error);&#10;                    navigateToMainActivity();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void navigateToMainActivity() {&#10;        Intent intent = new Intent(RegisterActivity.this, com.sgionotes.activities.MainActivity.class);&#10;        startActivity(intent);&#10;        finish();&#10;    }&#10;&#10;    private void saveUserProfile() {&#10;        UserProfileManager profileManager = new UserProfileManager(this);&#10;&#10;        String nombres = txtNombres.getText().toString().trim();&#10;        String apellidos = txtApellidos.getText().toString().trim();&#10;        String email = txtCorreo.getText().toString().trim();&#10;        UserProfile profile = new UserProfile(nombres, apellidos, email, R.drawable.ic_person_24);&#10;        profileManager.saveUserProfile(profile);&#10;    }&#10;&#10;    private boolean validacionRegister() {&#10;&#10;        String nombres = txtNombres.getText().toString().trim();&#10;        String apellidos = txtApellidos.getText().toString().trim();&#10;        String correo = txtCorreo.getText().toString().trim();&#10;        String password = txtPassword.getText().toString();&#10;&#10;        if (nombres.isEmpty() || apellidos.isEmpty() || correo.isEmpty() || password.isEmpty()) {&#10;            Snackbar.make(registerMain, &quot;Todos los campos son obligatorios&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        if (nombres.length() &gt; 80 || apellidos.length() &gt; 80) {&#10;            Snackbar.make(registerMain, &quot;Nombres y apellidos deben tener máximo 80 caracteres&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        Pattern patternCorreo = Pattern.compile(&quot;^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$&quot;);&#10;        if (!patternCorreo.matcher(correo).matches()) {&#10;            Snackbar.make(registerMain, &quot;Correo no válido&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        if (password.length() &lt; 8 || password.length() &gt; 50) {&#10;            Snackbar.make(registerMain, &quot;La contraseña debe tener entre 8 y 50 caracteres&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        Pattern patternPassword = Pattern.compile(&quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&amp;*()_+\\-=\\[\\]{};':\&quot;\\\\|,.&lt;&gt;/?]).+$&quot;);&#10;        if (!patternPassword.matcher(password).matches()) {&#10;            Snackbar.make(registerMain, &quot;La contraseña debe tener mayúsculas, minúsculas, número y carácter especial&quot;, Snackbar.LENGTH_LONG).show();&#10;            return false;&#10;        }&#10;&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/models/GenerarData.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/models/GenerarData.java" />
              <option name="originalContent" value="package com.sgionotes.models;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;public class GenerarData {&#10;&#10;    public interface DataInitializationCallback {&#10;        void onInitializationComplete();&#10;        void onInitializationError(String error);&#10;    }&#10;&#10;    private static GenerarData instancia;&#10;    private FirestoreRepository firestoreRepository;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private List&lt;Tag&gt; listaEtiquetas;&#10;    private GenerarData() {&#10;        listaNotas = new ArrayList&lt;&gt;();&#10;        listaEtiquetas = new ArrayList&lt;&gt;();&#10;    }&#10;    public static GenerarData getInstancia() {&#10;        if (instancia == null) {&#10;            instancia = new GenerarData();&#10;        }&#10;        return instancia;&#10;    }&#10;    public static GenerarData getInstance() {&#10;        return getInstancia();&#10;    }&#10;&#10;    public void initializeWithContext(Context context) {&#10;        if (firestoreRepository == null) {&#10;            firestoreRepository = new FirestoreRepository(context);&#10;            loadDataFromFirestore();&#10;        }&#10;    }&#10;&#10;    private void loadDataFromFirestore() {&#10;        if (firestoreRepository == null) return;&#10;        firestoreRepository.getAllNotes(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                listaNotas = notes;&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                listaNotas = new ArrayList&lt;&gt;();&#10;            }&#10;        });&#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                listaEtiquetas = tags;&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                listaEtiquetas = new ArrayList&lt;&gt;();&#10;            }&#10;        });&#10;    }&#10;&#10;    public FirestoreRepository getFirestoreRepository() {&#10;        return firestoreRepository;&#10;    }&#10;    public List&lt;Note&gt; getListaNotas() {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaNotas;&#10;    }&#10;    public List&lt;Tag&gt; getListaEtiquetas() {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaEtiquetas;&#10;    }&#10;    public void addNota(Note nota) {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaNotas.add(nota);&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveNote(nota, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {}&#10;&#10;                @Override&#10;                public void onError(String error) {}&#10;            });&#10;        }&#10;    }&#10;&#10;    public void addTag(Tag tag) {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaEtiquetas.add(tag);&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveTag(tag, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {}&#10;&#10;                @Override&#10;                public void onError(String error) {}&#10;            });&#10;        }&#10;    }&#10;    public void loadFavorites(Context context) {&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;                @Override&#10;                public void onSuccess(List&lt;Tag&gt; tags) {&#10;                    listaEtiquetas = tags;&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public void saveFavorites(Context context) {&#10;    }&#10;&#10;    public void createDefaultDataIfEmpty() {&#10;        createDefaultDataIfEmptyWithCallback(null);&#10;    }&#10;&#10;    public void createDefaultDataIfEmptyWithCallback(DataInitializationCallback callback) {&#10;        if (firestoreRepository == null) {&#10;            if (callback != null) callback.onInitializationError(&quot;Repository not initialized&quot;);&#10;            return;&#10;        }&#10;&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        if (currentUserId == null) {&#10;            if (callback != null) callback.onInitializationError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(&quot;GenerarData&quot;, &quot;Verificando datos para usuario: &quot; + currentUserId);&#10;&#10;        final boolean[] tagsChecked = {false};&#10;        final boolean[] notesChecked = {false};&#10;        final boolean[] tagsCreated = {false};&#10;        final boolean[] notesCreated = {false};&#10;&#10;        // Verificar etiquetas del usuario actual&#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                tagsChecked[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Tags encontrados para usuario &quot; + currentUserId + &quot;: &quot; + tags.size());&#10;&#10;                if (tags.isEmpty()) {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Creando tags por defecto para usuario nuevo: &quot; + currentUserId);&#10;                    createDefaultTagsWithCallback(() -&gt; {&#10;                        tagsCreated[0] = true;&#10;                        checkIfComplete(callback, tagsChecked, notesChecked, tagsCreated, notesCreated);&#10;                    });&#10;                } else {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Usuario ya tiene tags, no crear defaults&quot;);&#10;                    listaEtiquetas = tags;&#10;                    tagsCreated[0] = true;&#10;                    checkIfComplete(callback, tagsChecked, notesChecked, tagsCreated, notesCreated);&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error verificando tags: &quot; + error);&#10;                tagsChecked[0] = true;&#10;                // Solo crear si hay error de acceso, no si simplemente no existen&#10;                tagsCreated[0] = true;&#10;                checkIfComplete(callback, tagsChecked, notesChecked, tagsCreated, notesCreated);&#10;            }&#10;        });&#10;&#10;        // Verificar notas del usuario actual&#10;        firestoreRepository.getAllNotes(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                notesChecked[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Notas encontradas para usuario &quot; + currentUserId + &quot;: &quot; + notes.size());&#10;&#10;                if (notes.isEmpty()) {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Creando notas por defecto para usuario nuevo: &quot; + currentUserId);&#10;                    createDefaultNotes();&#10;                    notesCreated[0] = true;&#10;                } else {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Usuario ya tiene notas, no crear defaults&quot;);&#10;                    listaNotas = notes;&#10;                    notesCreated[0] = true;&#10;                }&#10;                checkIfComplete(callback, tagsChecked, notesChecked, tagsCreated, notesCreated);&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error verificando notas: &quot; + error);&#10;                notesChecked[0] = true;&#10;                // Solo crear si hay error de acceso, no si simplemente no existen&#10;                notesCreated[0] = true;&#10;                checkIfComplete(callback, tagsChecked, notesChecked, tagsCreated, notesCreated);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void checkIfComplete(DataInitializationCallback callback, boolean[] tagsChecked,&#10;                                boolean[] notesChecked, boolean[] tagsCreated, boolean[] notesCreated) {&#10;        if (callback != null &amp;&amp; tagsChecked[0] &amp;&amp; notesChecked[0] &amp;&amp; tagsCreated[0] &amp;&amp; notesCreated[0]) {&#10;            callback.onInitializationComplete();&#10;        }&#10;    }&#10;&#10;    private void createDefaultTags() {&#10;        createDefaultTagsWithCallback(null);&#10;    }&#10;&#10;    private void reloadTagsFromFirestore() {&#10;        reloadTagsFromFirestore(null);&#10;    }&#10;&#10;    private void createDefaultTagsWithCallback(Runnable onComplete) {&#10;        String[] defaultTagNames = {&quot;Trabajo&quot;, &quot;Importante&quot;, &quot;Ideas&quot;, &quot;Urgente&quot;};&#10;&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        // Obtener el userId del usuario actual&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        if (currentUserId == null) {&#10;            if (onComplete != null) onComplete.run();&#10;            return;&#10;        }&#10;&#10;        // Contador para esperar a que todas las etiquetas se guarden&#10;        final int totalTags = defaultTagNames.length;&#10;        final int[] savedCount = {0};&#10;&#10;        for (String tagName : defaultTagNames) {&#10;            // Crear etiqueta con userId del usuario actual&#10;            Tag tag = new Tag(null, tagName, currentUserId);&#10;            firestoreRepository.saveTag(tag, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    savedCount[0]++;&#10;                    // Cuando todas las etiquetas se hayan guardado, recargar desde Firestore&#10;                    if (savedCount[0] == totalTags) {&#10;                        // Reducir delay para login ultra rápido&#10;                        new android.os.Handler().postDelayed(new Runnable() {&#10;                            @Override&#10;                            public void run() {&#10;                                reloadTagsFromFirestore(onComplete);&#10;                            }&#10;                        }, 200); // Reducir a 200ms para login ultra rápido&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    savedCount[0]++;&#10;                    if (savedCount[0] == totalTags &amp;&amp; onComplete != null) {&#10;                        onComplete.run();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void reloadTagsFromFirestore(Runnable onComplete) {&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;                @Override&#10;                public void onSuccess(List&lt;Tag&gt; tags) {&#10;                    listaEtiquetas = tags;&#10;                    if (onComplete != null) {&#10;                        onComplete.run();&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    // Error al recargar etiquetas&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void createDefaultNotes() {&#10;        // Obtener el userId del usuario actual&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        if (currentUserId == null) {&#10;            return; // No crear notas si no hay usuario autenticado&#10;        }&#10;&#10;        // Crear notas de ejemplo con userId&#10;        Note nota1 = new Note(&quot;Lista de compras&quot;, &quot;Leche, pan, huevos, arroz, pollo, verduras y frutas.&quot;);&#10;        nota1.setUserId(currentUserId);&#10;&#10;        Note nota2 = new Note(&quot;Idea para proyecto&quot;, &quot;Crear una aplicación móvil para organizar tareas mediante inteligencia artificial.&quot;);&#10;        nota2.setUserId(currentUserId);&#10;&#10;        Note nota3 = new Note(&quot;Cita médica&quot;, &quot;Cita con el doctor Ramírez el lunes 12 a las 9:00 a.m.&quot;);&#10;        nota3.setUserId(currentUserId);&#10;&#10;        List&lt;Note&gt; defaultNotes = new ArrayList&lt;&gt;();&#10;        defaultNotes.add(nota1);&#10;        defaultNotes.add(nota2);&#10;        defaultNotes.add(nota3);&#10;&#10;        for (Note note : defaultNotes) {&#10;            firestoreRepository.saveNote(note, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    if (listaNotas == null) {&#10;                        listaNotas = new ArrayList&lt;&gt;();&#10;                    }&#10;                    listaNotas.add(note);&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    // Error al crear nota por defecto&#10;                }&#10;            });&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.sgionotes.models;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;public class GenerarData {&#10;&#10;    public interface DataInitializationCallback {&#10;        void onInitializationComplete();&#10;        void onInitializationError(String error);&#10;    }&#10;&#10;    private static GenerarData instancia;&#10;    private FirestoreRepository firestoreRepository;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private List&lt;Tag&gt; listaEtiquetas;&#10;    private GenerarData() {&#10;        listaNotas = new ArrayList&lt;&gt;();&#10;        listaEtiquetas = new ArrayList&lt;&gt;();&#10;    }&#10;    public static GenerarData getInstancia() {&#10;        if (instancia == null) {&#10;            instancia = new GenerarData();&#10;        }&#10;        return instancia;&#10;    }&#10;    public static GenerarData getInstance() {&#10;        return getInstancia();&#10;    }&#10;&#10;    public void initializeWithContext(Context context) {&#10;        if (firestoreRepository == null) {&#10;            firestoreRepository = new FirestoreRepository(context);&#10;            loadDataFromFirestore();&#10;        }&#10;    }&#10;&#10;    private void loadDataFromFirestore() {&#10;        if (firestoreRepository == null) return;&#10;        firestoreRepository.getAllNotes(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                listaNotas = notes;&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                listaNotas = new ArrayList&lt;&gt;();&#10;            }&#10;        });&#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                listaEtiquetas = tags;&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                listaEtiquetas = new ArrayList&lt;&gt;();&#10;            }&#10;        });&#10;    }&#10;&#10;    public FirestoreRepository getFirestoreRepository() {&#10;        return firestoreRepository;&#10;    }&#10;    public List&lt;Note&gt; getListaNotas() {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaNotas;&#10;    }&#10;    public List&lt;Tag&gt; getListaEtiquetas() {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaEtiquetas;&#10;    }&#10;    public void addNota(Note nota) {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaNotas.add(nota);&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveNote(nota, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {}&#10;&#10;                @Override&#10;                public void onError(String error) {}&#10;            });&#10;        }&#10;    }&#10;&#10;    public void addTag(Tag tag) {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaEtiquetas.add(tag);&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveTag(tag, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {}&#10;&#10;                @Override&#10;                public void onError(String error) {}&#10;            });&#10;        }&#10;    }&#10;    public void loadFavorites(Context context) {&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;                @Override&#10;                public void onSuccess(List&lt;Tag&gt; tags) {&#10;                    listaEtiquetas = tags;&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public void saveFavorites(Context context) {&#10;    }&#10;&#10;    public void createDefaultDataIfEmpty() {&#10;        createDefaultDataIfEmptyWithCallback(null);&#10;    }&#10;&#10;    public void createDefaultDataIfEmptyWithCallback(DataInitializationCallback callback) {&#10;        if (firestoreRepository == null) {&#10;            if (callback != null) callback.onInitializationError(&quot;Repository not initialized&quot;);&#10;            return;&#10;        }&#10;&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        if (currentUserId == null) {&#10;            if (callback != null) callback.onInitializationError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(&quot;GenerarData&quot;, &quot;Usuario autenticado: &quot; + currentUserId + &quot; - Iniciando con lienzo en blanco&quot;);&#10;&#10;        // Solo inicializar las listas vacías sin crear datos por defecto&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        // Cargar datos existentes del usuario (si los tiene)&#10;        final boolean[] tagsLoaded = {false};&#10;        final boolean[] notesLoaded = {false};&#10;&#10;        // Cargar etiquetas existentes del usuario&#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                listaEtiquetas = tags;&#10;                tagsLoaded[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Etiquetas cargadas para usuario &quot; + currentUserId + &quot;: &quot; + tags.size());&#10;                checkLoadingComplete(callback, tagsLoaded, notesLoaded);&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando etiquetas: &quot; + error);&#10;                listaEtiquetas = new ArrayList&lt;&gt;();&#10;                tagsLoaded[0] = true;&#10;                checkLoadingComplete(callback, tagsLoaded, notesLoaded);&#10;            }&#10;        });&#10;&#10;        // Cargar notas existentes del usuario&#10;        firestoreRepository.getAllNotes(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                listaNotas = notes;&#10;                notesLoaded[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Notas cargadas para usuario &quot; + currentUserId + &quot;: &quot; + notes.size());&#10;                checkLoadingComplete(callback, tagsLoaded, notesLoaded);&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando notas: &quot; + error);&#10;                listaNotas = new ArrayList&lt;&gt;();&#10;                notesLoaded[0] = true;&#10;                checkLoadingComplete(callback, tagsLoaded, notesLoaded);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void checkLoadingComplete(DataInitializationCallback callback, boolean[] tagsLoaded, boolean[] notesLoaded) {&#10;        if (callback != null &amp;&amp; tagsLoaded[0] &amp;&amp; notesLoaded[0]) {&#10;            callback.onInitializationComplete();&#10;        }&#10;    }&#10;&#10;    // Métodos legacy removidos - ya no se crean datos por defecto&#10;    // Los usuarios empiezan con un lienzo completamente en blanco&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java" />
              <option name="originalContent" value="package com.sgionotes.repository;&#10;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class FirestoreRepository {&#10;&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;    }&#10;&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;&#10;    private String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        return user != null ? user.getUid() : null;&#10;    }&#10;&#10;    // ===== OPERACIONES DE TAGS =====&#10;&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .orderBy(&quot;isFavorite&quot;, Query.Direction.DESCENDING)&#10;                .orderBy(&quot;favoriteTimestamp&quot;, Query.Direction.ASCENDING)&#10;                .orderBy(&quot;etiquetaDescripcion&quot;, Query.Direction.ASCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .whereEqualTo(&quot;isFavorite&quot;, true)&#10;                .orderBy(&quot;favoriteTimestamp&quot;, Query.Direction.ASCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Intentando guardar tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        tag.setUserId(userId);&#10;&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            // Crear nueva etiqueta&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar etiqueta existente&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        if (tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        if (tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    // ===== OPERACIONES DE NOTAS =====&#10;&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .whereEqualTo(&quot;isTrash&quot;, false)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .whereEqualTo(&quot;isTrash&quot;, true)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        note.setUserId(userId);&#10;        note.setTimestamp(System.currentTimeMillis());&#10;&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            // Crear nueva nota&#10;            db.collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar nota existente&#10;            db.collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        if (noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        if (noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        if (noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.repository;&#10;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class FirestoreRepository {&#10;&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;    }&#10;&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;&#10;    public String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        return user != null ? user.getUid() : null;&#10;    }&#10;&#10;    // ===== OPERACIONES DE TAGS =====&#10;&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .orderBy(&quot;isFavorite&quot;, Query.Direction.DESCENDING)&#10;                .orderBy(&quot;favoriteTimestamp&quot;, Query.Direction.ASCENDING)&#10;                .orderBy(&quot;etiquetaDescripcion&quot;, Query.Direction.ASCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .whereEqualTo(&quot;isFavorite&quot;, true)&#10;                .orderBy(&quot;favoriteTimestamp&quot;, Query.Direction.ASCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Intentando guardar tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        tag.setUserId(userId);&#10;&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            // Crear nueva etiqueta&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar etiqueta existente&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        if (tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        if (tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    // ===== OPERACIONES DE NOTAS =====&#10;&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .whereEqualTo(&quot;isTrash&quot;, false)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;userId&quot;, userId)&#10;                .whereEqualTo(&quot;isTrash&quot;, true)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        note.setUserId(userId);&#10;        note.setTimestamp(System.currentTimeMillis());&#10;&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            // Crear nueva nota&#10;            db.collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar nota existente&#10;            db.collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        if (noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        if (noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        if (noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>