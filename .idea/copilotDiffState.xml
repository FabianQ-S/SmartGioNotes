<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/adapters/NoteAdapter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/adapters/NoteAdapter.java" />
              <option name="originalContent" value="package com.sgionotes.adapters;&#10;&#10;import android.content.Context;&#10;import android.util.TypedValue;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.TextView;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import com.google.android.material.chip.Chip;&#10;import com.google.android.material.chip.ChipGroup;&#10;import com.sgionotes.R;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.Note;&#10;&#10;import java.util.List;&#10;&#10;public class NoteAdapter extends RecyclerView.Adapter&lt;NoteAdapter.NotaViewHolder&gt; {&#10;&#10;    private Context context;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private OnItemClickListener listener;&#10;&#10;    public void setOnItemClickListener(OnItemClickListener listener) {&#10;        this.listener = listener;&#10;    }&#10;&#10;    public interface OnItemClickListener {&#10;        void onItemClick(Note nota);&#10;    }&#10;&#10;    public NoteAdapter(Context context, List&lt;Note&gt; listaNotas) {&#10;        this.context = context;&#10;        this.listaNotas = listaNotas;&#10;    }&#10;&#10;    @Override&#10;    public NotaViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;        View vista = LayoutInflater.from(parent.getContext())&#10;                .inflate(R.layout.layout_tarjeta, parent, false);&#10;        return new NotaViewHolder(vista);&#10;    }&#10;&#10;    @Override&#10;    public void onBindViewHolder(@NonNull NotaViewHolder holder, int position) {&#10;&#10;        Note nota = listaNotas.get(position);&#10;        holder.txtIdNota.setText(String.valueOf(nota.getId()));&#10;        holder.txtTitulo.setText(nota.getTitulo());&#10;        holder.txtContenido.setText(nota.getContenido());&#10;&#10;        LayoutInflater inflater = LayoutInflater.from(context);&#10;        holder.chipGroup.removeAllViews();&#10;&#10;        for (Tag tag : nota.getEtiquetas()) {&#10;            Chip chip = (Chip) inflater.inflate(R.layout.layout_item_chip, holder.chipGroup, false);&#10;            chip.setClickable(false);&#10;            chip.setCheckable(false);&#10;            chip.setText(tag.getEtiquetaDescripcion());&#10;            holder.chipGroup.addView(chip);&#10;        }&#10;&#10;        holder.itemView.setOnClickListener(v -&gt; {&#10;            if (listener != null) {&#10;                listener.onItemClick(nota);&#10;            }&#10;        });&#10;&#10;    }&#10;&#10;    @Override&#10;    public int getItemCount() {&#10;        return listaNotas.size();&#10;    }&#10;&#10;    public static class NotaViewHolder extends RecyclerView.ViewHolder {&#10;        TextView txtIdNota;&#10;        TextView txtTitulo;&#10;        TextView txtContenido;&#10;        ChipGroup chipGroup;&#10;&#10;        public NotaViewHolder(View itemView) {&#10;            super(itemView);&#10;            txtIdNota = itemView.findViewById(R.id.txtIdNota);&#10;            txtTitulo = itemView.findViewById(R.id.txtTitulo);&#10;            txtContenido = itemView.findViewById(R.id.txtContenido);&#10;            chipGroup = itemView.findViewById(R.id.chipGroupEtiquetas);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.adapters;&#10;&#10;import android.content.Context;&#10;import android.util.TypedValue;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.TextView;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import com.google.android.material.chip.Chip;&#10;import com.google.android.material.chip.ChipGroup;&#10;import com.sgionotes.R;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.Note;&#10;&#10;import java.util.List;&#10;&#10;public class NoteAdapter extends RecyclerView.Adapter&lt;NoteAdapter.NotaViewHolder&gt; {&#10;&#10;    private Context context;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private OnItemClickListener listener;&#10;&#10;    public void setOnItemClickListener(OnItemClickListener listener) {&#10;        this.listener = listener;&#10;    }&#10;&#10;    public interface OnItemClickListener {&#10;        void onItemClick(Note nota);&#10;    }&#10;&#10;    public NoteAdapter(Context context, List&lt;Note&gt; listaNotas) {&#10;        this.context = context;&#10;        this.listaNotas = listaNotas;&#10;    }&#10;&#10;    @Override&#10;    public NotaViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;        View vista = LayoutInflater.from(parent.getContext())&#10;                .inflate(R.layout.layout_tarjeta, parent, false);&#10;        return new NotaViewHolder(vista);&#10;    }&#10;&#10;    @Override&#10;    public void onBindViewHolder(@NonNull NotaViewHolder holder, int position) {&#10;&#10;        Note nota = listaNotas.get(position);&#10;        holder.txtIdNota.setText(String.valueOf(nota.getId()));&#10;        holder.txtTitulo.setText(nota.getTitulo());&#10;        holder.txtContenido.setText(nota.getContenido());&#10;&#10;        LayoutInflater inflater = LayoutInflater.from(context);&#10;        holder.chipGroup.removeAllViews();&#10;&#10;        for (Tag tag : nota.getEtiquetas()) {&#10;            Chip chip = (Chip) inflater.inflate(R.layout.layout_item_chip, holder.chipGroup, false);&#10;            chip.setClickable(false);&#10;            chip.setCheckable(false);&#10;            chip.setText(tag.getEtiquetaDescripcion());&#10;            holder.chipGroup.addView(chip);&#10;        }&#10;&#10;        holder.itemView.setOnClickListener(v -&gt; {&#10;            if (listener != null) {&#10;                listener.onItemClick(nota);&#10;            }&#10;        });&#10;&#10;    }&#10;&#10;    @Override&#10;    public int getItemCount() {&#10;        return listaNotas.size();&#10;    }&#10;&#10;    public void updateNotes(List&lt;Note&gt; newNotes) {&#10;        this.listaNotas = newNotes;&#10;    }&#10;&#10;    public static class NotaViewHolder extends RecyclerView.ViewHolder {&#10;        TextView txtIdNota;&#10;        TextView txtTitulo;&#10;        TextView txtContenido;&#10;        ChipGroup chipGroup;&#10;&#10;        public NotaViewHolder(View itemView) {&#10;            super(itemView);&#10;            txtIdNota = itemView.findViewById(R.id.txtIdNota);&#10;            txtTitulo = itemView.findViewById(R.id.txtTitulo);&#10;            txtContenido = itemView.findViewById(R.id.txtContenido);&#10;            chipGroup = itemView.findViewById(R.id.chipGroupEtiquetas);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/fragments/NoteFragment.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/fragments/NoteFragment.java" />
              <option name="originalContent" value="package com.sgionotes.fragments;&#10;import android.app.Activity;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import androidx.activity.result.ActivityResultLauncher;&#10;import androidx.activity.result.contract.ActivityResultContracts;&#10;import androidx.annotation.NonNull;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.content.res.ColorStateList;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;import com.sgionotes.R;&#10;import com.sgionotes.activities.DetailNoteActivity;&#10;import com.sgionotes.adapters.NoteAdapter;&#10;import com.sgionotes.models.GenerarData;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class NoteFragment extends Fragment implements GenerarData.DataChangeListener {&#10;    private RecyclerView recyclerNotas;&#10;    private NoteAdapter notaAdapter;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private String titulo;&#10;    private String contenido;&#10;    private int lastId;&#10;    private FloatingActionButton floatingActionButton;&#10;    private GenerarData generarData;&#10;    public NoteFragment() {&#10;    }&#10;    private ActivityResultLauncher&lt;Intent&gt; launchNewNoteActivity;&#10;    @Override&#10;    public void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        launchNewNoteActivity = registerForActivityResult(&#10;                new ActivityResultContracts.StartActivityForResult(),&#10;                result -&gt; {&#10;                    if (result.getResultCode() == Activity.RESULT_OK &amp;&amp; result.getData() != null) {&#10;                        Intent data = result.getData();&#10;                        boolean esNueva = data.getBooleanExtra(&quot;esNueva&quot;, false);&#10;                        if (esNueva) {&#10;                            titulo = data.getStringExtra(&quot;titulo&quot;);&#10;                            contenido = data.getStringExtra(&quot;contenido&quot;);&#10;                            if (!titulo.isEmpty() || !contenido.isEmpty()) {&#10;                                Note nuevaNota = new Note(titulo, contenido);&#10;                                //FirstFirestore&#10;                                GenerarData.getInstance().getFirestoreRepository()&#10;                                        .saveNote(nuevaNota, new com.sgionotes.repository.FirestoreRepository.SimpleCallback() {&#10;                                            @Override&#10;                                            public void onSuccess() {&#10;                                                listaNotas.add(0, nuevaNota);&#10;                                                notaAdapter.notifyItemInserted(0);&#10;                                                recyclerNotas.scrollToPosition(0);&#10;                                            }&#10;                                            @Override&#10;                                            public void onError(String error) {&#10;                                                //Error&#10;                                                if (getContext() != null) {&#10;                                                    android.widget.Toast.makeText(getContext(),&#10;                                                            &quot;Error al guardar la nota: &quot; + error,&#10;                                                            android.widget.Toast.LENGTH_SHORT).show();&#10;                                                }&#10;                                            }&#10;                                        });&#10;                            }&#10;                        } else {&#10;                            int position = data.getIntExtra(&quot;position&quot;, -1);&#10;                            if (position != -1) {&#10;                                notaAdapter.notifyItemChanged(position);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;        );&#10;    }&#10;    @Override&#10;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {&#10;        View vista = inflater.inflate(R.layout.fragment_note, container, false);&#10;        recyclerNotas = vista.findViewById(R.id.recyclerNotas);&#10;        floatingActionButton = vista.findViewById(R.id.addNota);&#10;&#10;        recyclerNotas.setLayoutManager(&#10;                new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        );&#10;&#10;        generarData = GenerarData.getInstance();&#10;        generarData.addDataChangeListener(this);&#10;        listaNotas = generarData.getListaNotas();&#10;        notaAdapter = new NoteAdapter(getContext(), listaNotas);&#10;        recyclerNotas.setAdapter(notaAdapter);&#10;&#10;        notaAdapter.setOnItemClickListener(nota -&gt; {&#10;            int position = listaNotas.indexOf(nota);&#10;            Intent intent = new Intent(getContext(), DetailNoteActivity.class);&#10;            intent.putExtra(&quot;id&quot;, String.valueOf(nota.getId()));&#10;            intent.putExtra(&quot;titulo&quot;, nota.getTitulo());&#10;            intent.putExtra(&quot;contenido&quot;, nota.getContenido());&#10;            intent.putExtra(&quot;estaCreado&quot;, true);&#10;            intent.putExtra(&quot;position&quot;, position);&#10;            ArrayList&lt;String&gt; etiquetas = new ArrayList&lt;&gt;();&#10;            for (Tag tag : nota.getEtiquetas()) {&#10;                etiquetas.add(tag.getEtiquetaDescripcion());&#10;            }&#10;            intent.putStringArrayListExtra(&quot;etiquetas&quot;, etiquetas);&#10;            launchNewNoteActivity.launch(intent);&#10;        });&#10;        floatingActionButton.setOnClickListener(btn -&gt; {&#10;            Intent intent = new Intent(getContext(), DetailNoteActivity.class);&#10;            intent.putExtra(&quot;esNueva&quot;, true);&#10;            launchNewNoteActivity.launch(intent);&#10;        });&#10;&#10;        return vista;&#10;    }&#10;    @Override&#10;    public void onResume() {&#10;        super.onResume();&#10;        if (generarData != null) {&#10;            listaNotas = generarData.getListaNotas();&#10;            if (notaAdapter != null) {&#10;                notaAdapter.notifyDataSetChanged();&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        if (generarData != null) {&#10;            generarData.removeDataChangeListener(this);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDataChanged() {&#10;        if (getActivity() != null) {&#10;            getActivity().runOnUiThread(() -&gt; {&#10;                if (generarData != null) {&#10;                    List&lt;Note&gt; updatedNotes = generarData.getListaNotas();&#10;                    if (updatedNotes != listaNotas) {&#10;                        listaNotas = updatedNotes;&#10;                        if (notaAdapter != null) {&#10;                            notaAdapter = new NoteAdapter(getContext(), listaNotas);&#10;                            recyclerNotas.setAdapter(notaAdapter);&#10;                            notaAdapter.setOnItemClickListener(nota -&gt; {&#10;                                int position = listaNotas.indexOf(nota);&#10;                                Intent intent = new Intent(getContext(), DetailNoteActivity.class);&#10;                                intent.putExtra(&quot;id&quot;, String.valueOf(nota.getId()));&#10;                                intent.putExtra(&quot;titulo&quot;, nota.getTitulo());&#10;                                intent.putExtra(&quot;contenido&quot;, nota.getContenido());&#10;                                intent.putExtra(&quot;estaCreado&quot;, true);&#10;                                intent.putExtra(&quot;position&quot;, position);&#10;                                ArrayList&lt;String&gt; etiquetas = new ArrayList&lt;&gt;();&#10;                                for (Tag tag : nota.getEtiquetas()) {&#10;                                    etiquetas.add(tag.getEtiquetaDescripcion());&#10;                                }&#10;                                intent.putStringArrayListExtra(&quot;etiquetas&quot;, etiquetas);&#10;                                launchNewNoteActivity.launch(intent);&#10;                            });&#10;                        }&#10;                    } else {&#10;                        if (notaAdapter != null) {&#10;                            notaAdapter.notifyDataSetChanged();&#10;                        }&#10;                    }&#10;&#10;                    android.util.Log.d(&quot;NoteFragment&quot;, &quot;Datos actualizados - mostrando &quot; + listaNotas.size() + &quot; notas&quot;);&#10;                }&#10;            });&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.fragments;&#10;import android.app.Activity;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import androidx.activity.result.ActivityResultLauncher;&#10;import androidx.activity.result.contract.ActivityResultContracts;&#10;import androidx.annotation.NonNull;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.content.res.ColorStateList;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;import com.sgionotes.R;&#10;import com.sgionotes.activities.DetailNoteActivity;&#10;import com.sgionotes.adapters.NoteAdapter;&#10;import com.sgionotes.models.GenerarData;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class NoteFragment extends Fragment implements GenerarData.DataChangeListener {&#10;    private RecyclerView recyclerNotas;&#10;    private NoteAdapter notaAdapter;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private String titulo;&#10;    private String contenido;&#10;    private int lastId;&#10;    private FloatingActionButton floatingActionButton;&#10;    private GenerarData generarData;&#10;    public NoteFragment() {&#10;    }&#10;    private ActivityResultLauncher&lt;Intent&gt; launchNewNoteActivity;&#10;    @Override&#10;    public void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        launchNewNoteActivity = registerForActivityResult(&#10;                new ActivityResultContracts.StartActivityForResult(),&#10;                result -&gt; {&#10;                    if (result.getResultCode() == Activity.RESULT_OK &amp;&amp; result.getData() != null) {&#10;                        Intent data = result.getData();&#10;                        boolean esNueva = data.getBooleanExtra(&quot;esNueva&quot;, false);&#10;                        if (esNueva) {&#10;                            titulo = data.getStringExtra(&quot;titulo&quot;);&#10;                            contenido = data.getStringExtra(&quot;contenido&quot;);&#10;                            if (!titulo.isEmpty() || !contenido.isEmpty()) {&#10;                                Note nuevaNota = new Note(titulo, contenido);&#10;                                //FirstFirestore&#10;                                GenerarData.getInstance().getFirestoreRepository()&#10;                                        .saveNote(nuevaNota, new com.sgionotes.repository.FirestoreRepository.SimpleCallback() {&#10;                                            @Override&#10;                                            public void onSuccess() {&#10;                                                listaNotas.add(0, nuevaNota);&#10;                                                notaAdapter.notifyItemInserted(0);&#10;                                                recyclerNotas.scrollToPosition(0);&#10;                                            }&#10;                                            @Override&#10;                                            public void onError(String error) {&#10;                                                //Error&#10;                                                if (getContext() != null) {&#10;                                                    android.widget.Toast.makeText(getContext(),&#10;                                                            &quot;Error al guardar la nota: &quot; + error,&#10;                                                            android.widget.Toast.LENGTH_SHORT).show();&#10;                                                }&#10;                                            }&#10;                                        });&#10;                            }&#10;                        } else {&#10;                            int position = data.getIntExtra(&quot;position&quot;, -1);&#10;                            if (position != -1) {&#10;                                notaAdapter.notifyItemChanged(position);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;        );&#10;    }&#10;    @Override&#10;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {&#10;        View vista = inflater.inflate(R.layout.fragment_note, container, false);&#10;        recyclerNotas = vista.findViewById(R.id.recyclerNotas);&#10;        floatingActionButton = vista.findViewById(R.id.addNota);&#10;&#10;        recyclerNotas.setLayoutManager(&#10;                new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        );&#10;&#10;        generarData = GenerarData.getInstance();&#10;        generarData.addDataChangeListener(this);&#10;        &#10;        // Filtrar solo las notas activas (no en papelera)&#10;        listaNotas = getActiveNotes();&#10;        notaAdapter = new NoteAdapter(getContext(), listaNotas);&#10;        recyclerNotas.setAdapter(notaAdapter);&#10;&#10;        notaAdapter.setOnItemClickListener(nota -&gt; {&#10;            int position = listaNotas.indexOf(nota);&#10;            Intent intent = new Intent(getContext(), DetailNoteActivity.class);&#10;            intent.putExtra(&quot;id&quot;, String.valueOf(nota.getId()));&#10;            intent.putExtra(&quot;titulo&quot;, nota.getTitulo());&#10;            intent.putExtra(&quot;contenido&quot;, nota.getContenido());&#10;            intent.putExtra(&quot;estaCreado&quot;, true);&#10;            intent.putExtra(&quot;position&quot;, position);&#10;            ArrayList&lt;String&gt; etiquetas = new ArrayList&lt;&gt;();&#10;            for (Tag tag : nota.getEtiquetas()) {&#10;                etiquetas.add(tag.getEtiquetaDescripcion());&#10;            }&#10;            intent.putStringArrayListExtra(&quot;etiquetas&quot;, etiquetas);&#10;            launchNewNoteActivity.launch(intent);&#10;        });&#10;        floatingActionButton.setOnClickListener(btn -&gt; {&#10;            Intent intent = new Intent(getContext(), DetailNoteActivity.class);&#10;            intent.putExtra(&quot;esNueva&quot;, true);&#10;            launchNewNoteActivity.launch(intent);&#10;        });&#10;&#10;        return vista;&#10;    }&#10;&#10;    private List&lt;Note&gt; getActiveNotes() {&#10;        List&lt;Note&gt; activeNotes = new ArrayList&lt;&gt;();&#10;        if (generarData != null) {&#10;            for (Note note : generarData.getListaNotas()) {&#10;                if (!note.isTrash()) {&#10;                    activeNotes.add(note);&#10;                }&#10;            }&#10;        }&#10;        return activeNotes;&#10;    }&#10;&#10;    @Override&#10;    public void onResume() {&#10;        super.onResume();&#10;        if (generarData != null) {&#10;            listaNotas = getActiveNotes();&#10;            if (notaAdapter != null) {&#10;                notaAdapter.updateNotes(listaNotas);&#10;                notaAdapter.notifyDataSetChanged();&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        if (generarData != null) {&#10;            generarData.removeDataChangeListener(this);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDataChanged() {&#10;        if (getActivity() != null) {&#10;            getActivity().runOnUiThread(() -&gt; {&#10;                if (generarData != null) {&#10;                    List&lt;Note&gt; updatedActiveNotes = getActiveNotes();&#10;                    listaNotas = updatedActiveNotes;&#10;                    if (notaAdapter != null) {&#10;                        notaAdapter.updateNotes(listaNotas);&#10;                        notaAdapter.notifyDataSetChanged();&#10;                    }&#10;                }&#10;            });&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/fragments/TrashFragment.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/fragments/TrashFragment.java" />
              <option name="originalContent" value="package com.sgionotes.fragments;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.Button;&#10;import android.widget.Toast;&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder;&#10;import com.sgionotes.R;&#10;import com.sgionotes.activities.DetailNoteActivity;&#10;import com.sgionotes.adapters.NoteAdapter;&#10;import com.sgionotes.models.GenerarData;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;public class TrashFragment extends Fragment implements GenerarData.DataChangeListener {&#10;    private RecyclerView recyclerTrashNotes;&#10;    private NoteAdapter notaAdapter;&#10;    private List&lt;Note&gt; listaNotasTrash;&#10;    private Button btnVaciarPapelera;&#10;    private GenerarData generarData;&#10;&#10;    public TrashFragment() {&#10;    }&#10;&#10;    @Override&#10;    public View onCreateView(LayoutInflater inflater, ViewGroup container,&#10;                             Bundle savedInstanceState) {&#10;        View vista = inflater.inflate(R.layout.fragment_trash, container, false);&#10;        generarData = GenerarData.getInstancia();&#10;        generarData.addDataChangeListener(this);&#10;        recyclerTrashNotes = vista.findViewById(R.id.recyclerTrashNotes);&#10;        btnVaciarPapelera = vista.findViewById(R.id.btnVaciarPapelera);&#10;        recyclerTrashNotes.setLayoutManager(&#10;                new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        );&#10;&#10;        cargarNotasPapelera();&#10;        notaAdapter = new NoteAdapter(getContext(), listaNotasTrash);&#10;        recyclerTrashNotes.setAdapter(notaAdapter);&#10;        notaAdapter.setOnItemClickListener(nota -&gt; {&#10;            mostrarDialogoEliminarNotaIndividual(nota);&#10;        });&#10;        btnVaciarPapelera.setOnClickListener(btn -&gt; {&#10;            mostrarDialogoVaciarPapelera();&#10;        });&#10;&#10;        return vista;&#10;    }&#10;&#10;    private void cargarNotasPapelera() {&#10;        listaNotasTrash = generarData.getListaNotas()&#10;                .stream()&#10;                .filter(Note::isTrash)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    private void mostrarDialogoEliminarNotaIndividual(Note nota) {&#10;        MaterialAlertDialogBuilder dialog = new MaterialAlertDialogBuilder(requireContext())&#10;                .setMessage(&quot;La nota se eliminará permanentemente&quot;)&#10;                .setPositiveButton(&quot;Aceptar&quot;, (dialogInterface, which) -&gt; {&#10;                    eliminarNotaIndividual(nota.getId());&#10;                })&#10;                .setNegativeButton(&quot;Cancelar&quot;, null);&#10;        androidx.appcompat.app.AlertDialog alertDialog = dialog.create();&#10;        alertDialog.setOnShowListener(dialogInterface -&gt; {&#10;            boolean isDarkMode = (getResources().getConfiguration().uiMode &amp;&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_MASK) ==&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_YES;&#10;            int buttonColor = isDarkMode ?&#10;                    getResources().getColor(R.color.purple, requireContext().getTheme()) :&#10;                    getResources().getColor(R.color.cian, requireContext().getTheme());&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_POSITIVE)&#10;                    .setTextColor(buttonColor);&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_NEGATIVE)&#10;                    .setTextColor(buttonColor);&#10;        });&#10;        alertDialog.show();&#10;    }&#10;    private void eliminarNotaIndividual(String noteId) {&#10;        generarData.getFirestoreRepository().deleteNotePermanently(noteId, new FirestoreRepository.SimpleCallback() {&#10;            @Override&#10;            public void onSuccess() {&#10;                if (getActivity() != null) {&#10;                    getActivity().runOnUiThread(() -&gt; {&#10;                        generarData.refreshDataForCurrentUser();&#10;                        Toast.makeText(getContext(), &quot;Nota eliminada permanentemente&quot;, Toast.LENGTH_SHORT).show();&#10;                        actualizarLista();&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                if (getActivity() != null) {&#10;                    getActivity().runOnUiThread(() -&gt; {&#10;                        Toast.makeText(getContext(), &quot;Error al eliminar nota: &quot; + error, Toast.LENGTH_SHORT).show();&#10;                    });&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void mostrarDialogoVaciarPapelera() {&#10;        MaterialAlertDialogBuilder dialog = new MaterialAlertDialogBuilder(requireContext())&#10;                .setMessage(&quot;¿Está seguro de eliminar permanentemente las notas?&quot;)&#10;                .setPositiveButton(&quot;Aceptar&quot;, (dialogInterface, which) -&gt; {&#10;                    vaciarPapelera();&#10;                })&#10;                .setNegativeButton(&quot;Cancelar&quot;, null);&#10;&#10;        androidx.appcompat.app.AlertDialog alertDialog = dialog.create();&#10;        alertDialog.setOnShowListener(dialogInterface -&gt; {&#10;            boolean isDarkMode = (getResources().getConfiguration().uiMode &amp;&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_MASK) ==&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_YES;&#10;            int buttonColor = isDarkMode ?&#10;                    getResources().getColor(R.color.purple, requireContext().getTheme()) :&#10;                    getResources().getColor(R.color.cian, requireContext().getTheme());&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_POSITIVE)&#10;                    .setTextColor(buttonColor);&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_NEGATIVE)&#10;                    .setTextColor(buttonColor);&#10;        });&#10;        alertDialog.show();&#10;    }&#10;&#10;    private void vaciarPapelera() {&#10;        List&lt;Note&gt; notasEnPapelera = generarData.getListaNotas()&#10;                .stream()&#10;                .filter(Note::isTrash)&#10;                .collect(Collectors.toList());&#10;&#10;        if (notasEnPapelera.isEmpty()) {&#10;            Toast.makeText(getContext(), &quot;La papelera ya está vacía&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        int totalNotas = notasEnPapelera.size();&#10;        int[] notasEliminadas = {0};&#10;&#10;        for (Note nota : notasEnPapelera) {&#10;            generarData.getFirestoreRepository().deleteNotePermanently(nota.getId(), new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    notasEliminadas[0]++;&#10;                    if (notasEliminadas[0] == totalNotas) {&#10;                        if (getActivity() != null) {&#10;                            getActivity().runOnUiThread(() -&gt; {&#10;                                // Refrescar datos desde Firebase como se hace en eliminación individual&#10;                                generarData.refreshDataForCurrentUser();&#10;                                Toast.makeText(getContext(), &quot;Papelera vaciada correctamente&quot;, Toast.LENGTH_SHORT).show();&#10;                                actualizarLista();&#10;                            });&#10;                        }&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    if (getActivity() != null) {&#10;                        getActivity().runOnUiThread(() -&gt; {&#10;                            Toast.makeText(getContext(), &quot;Error al vaciar papelera: &quot; + error, Toast.LENGTH_SHORT).show();&#10;                        });&#10;                    }&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void actualizarLista() {&#10;        cargarNotasPapelera();&#10;        if (notaAdapter != null) {&#10;            notaAdapter.updateNotes(listaNotasTrash);&#10;            notaAdapter.notifyDataSetChanged();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDataChanged() {&#10;        if (getActivity() != null) {&#10;            getActivity().runOnUiThread(() -&gt; {&#10;                actualizarLista();&#10;            });&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        if (generarData != null) {&#10;            generarData.removeDataChangeListener(this);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onResume() {&#10;        super.onResume();&#10;        if (generarData != null) {&#10;            actualizarLista();&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.sgionotes.fragments;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.Button;&#10;import android.widget.Toast;&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder;&#10;import com.sgionotes.R;&#10;import com.sgionotes.activities.DetailNoteActivity;&#10;import com.sgionotes.adapters.NoteAdapter;&#10;import com.sgionotes.models.GenerarData;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;public class TrashFragment extends Fragment implements GenerarData.DataChangeListener {&#10;    private RecyclerView recyclerTrashNotes;&#10;    private NoteAdapter notaAdapter;&#10;    private List&lt;Note&gt; listaNotasTrash;&#10;    private Button btnVaciarPapelera;&#10;    private GenerarData generarData;&#10;&#10;    public TrashFragment() {&#10;    }&#10;&#10;    @Override&#10;    public View onCreateView(LayoutInflater inflater, ViewGroup container,&#10;                             Bundle savedInstanceState) {&#10;        View vista = inflater.inflate(R.layout.fragment_trash, container, false);&#10;        generarData = GenerarData.getInstancia();&#10;        generarData.addDataChangeListener(this);&#10;        recyclerTrashNotes = vista.findViewById(R.id.recyclerTrashNotes);&#10;        btnVaciarPapelera = vista.findViewById(R.id.btnVaciarPapelera);&#10;        recyclerTrashNotes.setLayoutManager(&#10;                new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        );&#10;&#10;        cargarNotasPapelera();&#10;        notaAdapter = new NoteAdapter(getContext(), listaNotasTrash);&#10;        recyclerTrashNotes.setAdapter(notaAdapter);&#10;        notaAdapter.setOnItemClickListener(nota -&gt; {&#10;            mostrarDialogoEliminarNotaIndividual(nota);&#10;        });&#10;        btnVaciarPapelera.setOnClickListener(btn -&gt; {&#10;            mostrarDialogoVaciarPapelera();&#10;        });&#10;&#10;        return vista;&#10;    }&#10;&#10;    private void cargarNotasPapelera() {&#10;        listaNotasTrash = generarData.getListaNotas()&#10;                .stream()&#10;                .filter(Note::isTrash)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    private void mostrarDialogoEliminarNotaIndividual(Note nota) {&#10;        MaterialAlertDialogBuilder dialog = new MaterialAlertDialogBuilder(requireContext())&#10;                .setMessage(&quot;¿Desea restaurar o eliminar permanentemente la nota?&quot;)&#10;                .setPositiveButton(&quot;Restaurar&quot;, (dialogInterface, which) -&gt; {&#10;                    restaurarNota(nota.getId());&#10;                })&#10;                .setNegativeButton(&quot;Eliminar&quot;, (dialogInterface, which) -&gt; {&#10;                    eliminarNotaIndividual(nota.getId());&#10;                });&#10;&#10;        androidx.appcompat.app.AlertDialog alertDialog = dialog.create();&#10;        alertDialog.setOnShowListener(dialogInterface -&gt; {&#10;            boolean isDarkMode = (getResources().getConfiguration().uiMode &amp;&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_MASK) ==&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_YES;&#10;&#10;            // Color para el botón Restaurar (color actual del tema)&#10;            int restoreButtonColor = isDarkMode ?&#10;                    getResources().getColor(R.color.purple, requireContext().getTheme()) :&#10;                    getResources().getColor(R.color.cian, requireContext().getTheme());&#10;&#10;            // Color rojo para el botón Eliminar (independiente del tema)&#10;            int deleteButtonColor = getResources().getColor(android.R.color.holo_red_dark, requireContext().getTheme());&#10;&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_POSITIVE)&#10;                    .setTextColor(restoreButtonColor);&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_NEGATIVE)&#10;                    .setTextColor(deleteButtonColor);&#10;        });&#10;        alertDialog.show();&#10;    }&#10;&#10;    private void restaurarNota(String noteId) {&#10;        generarData.getFirestoreRepository().restoreNoteFromTrash(noteId, new FirestoreRepository.SimpleCallback() {&#10;            @Override&#10;            public void onSuccess() {&#10;                if (getActivity() != null) {&#10;                    getActivity().runOnUiThread(() -&gt; {&#10;                        generarData.refreshDataForCurrentUser();&#10;                        Toast.makeText(getContext(), &quot;Nota restaurada correctamente&quot;, Toast.LENGTH_SHORT).show();&#10;                        actualizarLista();&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                if (getActivity() != null) {&#10;                    getActivity().runOnUiThread(() -&gt; {&#10;                        Toast.makeText(getContext(), &quot;Error al restaurar nota: &quot; + error, Toast.LENGTH_SHORT).show();&#10;                    });&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void eliminarNotaIndividual(String noteId) {&#10;        generarData.getFirestoreRepository().deleteNotePermanently(noteId, new FirestoreRepository.SimpleCallback() {&#10;            @Override&#10;            public void onSuccess() {&#10;                if (getActivity() != null) {&#10;                    getActivity().runOnUiThread(() -&gt; {&#10;                        generarData.refreshDataForCurrentUser();&#10;                        Toast.makeText(getContext(), &quot;Nota eliminada permanentemente&quot;, Toast.LENGTH_SHORT).show();&#10;                        actualizarLista();&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                if (getActivity() != null) {&#10;                    getActivity().runOnUiThread(() -&gt; {&#10;                        Toast.makeText(getContext(), &quot;Error al eliminar nota: &quot; + error, Toast.LENGTH_SHORT).show();&#10;                    });&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private void mostrarDialogoVaciarPapelera() {&#10;        MaterialAlertDialogBuilder dialog = new MaterialAlertDialogBuilder(requireContext())&#10;                .setMessage(&quot;¿Está seguro de eliminar permanentemente las notas?&quot;)&#10;                .setPositiveButton(&quot;Aceptar&quot;, (dialogInterface, which) -&gt; {&#10;                    vaciarPapelera();&#10;                })&#10;                .setNegativeButton(&quot;Cancelar&quot;, null);&#10;&#10;        androidx.appcompat.app.AlertDialog alertDialog = dialog.create();&#10;        alertDialog.setOnShowListener(dialogInterface -&gt; {&#10;            boolean isDarkMode = (getResources().getConfiguration().uiMode &amp;&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_MASK) ==&#10;                    android.content.res.Configuration.UI_MODE_NIGHT_YES;&#10;            int buttonColor = isDarkMode ?&#10;                    getResources().getColor(R.color.purple, requireContext().getTheme()) :&#10;                    getResources().getColor(R.color.cian, requireContext().getTheme());&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_POSITIVE)&#10;                    .setTextColor(buttonColor);&#10;            alertDialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_NEGATIVE)&#10;                    .setTextColor(buttonColor);&#10;        });&#10;        alertDialog.show();&#10;    }&#10;&#10;    private void vaciarPapelera() {&#10;        List&lt;Note&gt; notasEnPapelera = generarData.getListaNotas()&#10;                .stream()&#10;                .filter(Note::isTrash)&#10;                .collect(Collectors.toList());&#10;&#10;        if (notasEnPapelera.isEmpty()) {&#10;            Toast.makeText(getContext(), &quot;La papelera ya está vacía&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        int totalNotas = notasEnPapelera.size();&#10;        int[] notasEliminadas = {0};&#10;&#10;        for (Note nota : notasEnPapelera) {&#10;            generarData.getFirestoreRepository().deleteNotePermanently(nota.getId(), new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    notasEliminadas[0]++;&#10;                    if (notasEliminadas[0] == totalNotas) {&#10;                        if (getActivity() != null) {&#10;                            getActivity().runOnUiThread(() -&gt; {&#10;                                // Refrescar datos desde Firebase como se hace en eliminación individual&#10;                                generarData.refreshDataForCurrentUser();&#10;                                Toast.makeText(getContext(), &quot;Papelera vaciada correctamente&quot;, Toast.LENGTH_SHORT).show();&#10;                                actualizarLista();&#10;                            });&#10;                        }&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    if (getActivity() != null) {&#10;                        getActivity().runOnUiThread(() -&gt; {&#10;                            Toast.makeText(getContext(), &quot;Error al vaciar papelera: &quot; + error, Toast.LENGTH_SHORT).show();&#10;                        });&#10;                    }&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void actualizarLista() {&#10;        cargarNotasPapelera();&#10;        if (notaAdapter != null) {&#10;            notaAdapter.updateNotes(listaNotasTrash);&#10;            notaAdapter.notifyDataSetChanged();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDataChanged() {&#10;        if (getActivity() != null) {&#10;            getActivity().runOnUiThread(() -&gt; {&#10;                actualizarLista();&#10;            });&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        if (generarData != null) {&#10;            generarData.removeDataChangeListener(this);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onResume() {&#10;        super.onResume();&#10;        if (generarData != null) {&#10;            actualizarLista();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/models/GenerarData.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/models/GenerarData.java" />
              <option name="originalContent" value="package com.sgionotes.models;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;public class GenerarData {&#10;    public interface DataChangeListener {&#10;        void onDataChanged();&#10;    }&#10;    public interface DataInitializationCallback {&#10;        void onInitializationComplete();&#10;        void onInitializationError(String error);&#10;    }&#10;    private static GenerarData instancia;&#10;    private FirestoreRepository firestoreRepository;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private List&lt;Tag&gt; listaEtiquetas;&#10;    private List&lt;DataChangeListener&gt; dataChangeListeners;&#10;&#10;    private GenerarData() {&#10;        listaNotas = new ArrayList&lt;&gt;();&#10;        listaEtiquetas = new ArrayList&lt;&gt;();&#10;        dataChangeListeners = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    public static GenerarData getInstancia() {&#10;        if (instancia == null) {&#10;            instancia = new GenerarData();&#10;        }&#10;        return instancia;&#10;    }&#10;&#10;    public static GenerarData getInstance() {&#10;        return getInstancia();&#10;    }&#10;&#10;    //Metodos&#10;    public void addDataChangeListener(DataChangeListener listener) {&#10;        if (!dataChangeListeners.contains(listener)) {&#10;            dataChangeListeners.add(listener);&#10;        }&#10;    }&#10;    public void removeDataChangeListener(DataChangeListener listener) {&#10;        dataChangeListeners.remove(listener);&#10;    }&#10;    private void notifyDataChanged() {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Notificando cambio de datos a &quot; + dataChangeListeners.size() + &quot; listeners - Notas: &quot; + getListaNotas().size() + &quot;, Etiquetas: &quot; + getListaEtiquetas().size());&#10;        for (DataChangeListener listener : dataChangeListeners) {&#10;            listener.onDataChanged();&#10;        }&#10;    }&#10;    public void initializeWithContext(Context context) {&#10;        if (firestoreRepository == null) {&#10;            firestoreRepository = new FirestoreRepository(context);&#10;        }&#10;        loadDataFromFirestore(); //CargarDatos&#10;    }&#10;    private void loadDataFromFirestore() {&#10;        if (firestoreRepository == null) return;&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        Log.d(&quot;GenerarData&quot;, &quot;Cargando datos para usuario: &quot; + currentUserId);&#10;&#10;        // Usar getAllNotesIncludingTrash para obtener TODAS las notas (incluida papelera)&#10;        firestoreRepository.getAllNotesIncludingTrash(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                listaNotas = notes;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Notas cargadas exitosamente: &quot; + notes.size() + &quot; notas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaNotas = new ArrayList&lt;&gt;();&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando notas: &quot; + error);&#10;                notifyDataChanged();&#10;            }&#10;        });&#10;        &#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                listaEtiquetas = tags;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Etiquetas cargadas exitosamente: &quot; + tags.size() + &quot; etiquetas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaEtiquetas = new ArrayList&lt;&gt;();&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando etiquetas: &quot; + error);&#10;                notifyDataChanged();&#10;            }&#10;        });&#10;    }&#10;&#10;    public FirestoreRepository getFirestoreRepository() {&#10;        return firestoreRepository;&#10;    }&#10;&#10;    public List&lt;Note&gt; getListaNotas() {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaNotas;&#10;    }&#10;&#10;    public List&lt;Tag&gt; getListaEtiquetas() {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaEtiquetas;&#10;    }&#10;&#10;    public void addNota(Note nota) {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaNotas.add(nota);&#10;        notifyDataChanged();&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveNote(nota, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Nota guardada exitosamente en Firestore&quot;);&#10;                }&#10;                @Override&#10;                public void onError(String error) {&#10;                    Log.e(&quot;GenerarData&quot;, &quot;Error guardando nota: &quot; + error);&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public void addTag(Tag tag) {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaEtiquetas.add(tag);&#10;        notifyDataChanged();&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveTag(tag, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Etiqueta guardada exitosamente en Firestore&quot;);&#10;                }&#10;                @Override&#10;                public void onError(String error) {&#10;                    Log.e(&quot;GenerarData&quot;, &quot;Error guardando etiqueta: &quot; + error);&#10;                }&#10;            });&#10;        }&#10;    }&#10;    public void clearUserData() {&#10;        if (listaNotas != null) {&#10;            listaNotas.clear();&#10;        }&#10;        if (listaEtiquetas != null) {&#10;            listaEtiquetas.clear();&#10;        }&#10;        notifyDataChanged();&#10;    }&#10;    public void forceReloadUserData() {&#10;        clearUserData();&#10;        loadDataFromFirestore();&#10;    }&#10;    public void refreshDataForCurrentUser() {&#10;        refreshDataForCurrentUser(null);&#10;    }&#10;    public void refreshDataForCurrentUser(DataInitializationCallback callback) {&#10;        String currentUserId = firestoreRepository != null ? firestoreRepository.getCurrentUserId() : null;&#10;        if (currentUserId != null) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Refrescando datos para usuario actual: &quot; + currentUserId);&#10;            clearUserData();&#10;            loadDataFromFirestoreWithCallback(callback);&#10;        } else {&#10;            Log.w(&quot;GenerarData&quot;, &quot;No hay usuario autenticado para refrescar datos&quot;);&#10;            if (callback != null) {&#10;                callback.onInitializationError(&quot;No hay usuario autenticado&quot;);&#10;            }&#10;        }&#10;    }&#10;    private void loadDataFromFirestoreWithCallback(DataInitializationCallback callback) {&#10;        if (firestoreRepository == null) {&#10;            if (callback != null) callback.onInitializationError(&quot;Repository not initialized&quot;);&#10;            return;&#10;        }&#10;&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        Log.d(&quot;GenerarData&quot;, &quot;Cargando datos con callback para usuario: &quot; + currentUserId);&#10;        final boolean[] notesLoaded = {false};&#10;        final boolean[] tagsLoaded = {false};&#10;        //Cargar&#10;        firestoreRepository.getAllNotes(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                listaNotas = notes;&#10;                notesLoaded[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Notas cargadas con callback: &quot; + notes.size() + &quot; notas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaNotas = new ArrayList&lt;&gt;();&#10;                notesLoaded[0] = true;&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando notas con callback: &quot; + error);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;        });&#10;&#10;        //CargarEtiquetas&#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                listaEtiquetas = tags;&#10;                tagsLoaded[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Etiquetas cargadas con callback: &quot; + tags.size() + &quot; etiquetas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaEtiquetas = new ArrayList&lt;&gt;();&#10;                tagsLoaded[0] = true;&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando etiquetas con callback: &quot; + error);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;        });&#10;    }&#10;    private void checkCallbackCompletion(DataInitializationCallback callback, boolean[] notesLoaded, boolean[] tagsLoaded) {&#10;        if (callback != null &amp;&amp; notesLoaded[0] &amp;&amp; tagsLoaded[0]) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Datos completamente cargados - ejecutando callback&quot;);&#10;            notifyDataChanged();&#10;            callback.onInitializationComplete();&#10;        }&#10;    }&#10;    public void forceUpdateAllFragments() {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Forzando actualización de todos los fragmentos&quot;);&#10;        notifyDataChanged();&#10;    }&#10;&#10;    public boolean hasDataLoaded() {&#10;        return (listaNotas != null &amp;&amp; !listaNotas.isEmpty()) ||&#10;               (listaEtiquetas != null &amp;&amp; !listaEtiquetas.isEmpty());&#10;    }&#10;&#10;    public void ensureDataLoaded(DataInitializationCallback callback) {&#10;        String currentUserId = firestoreRepository != null ? firestoreRepository.getCurrentUserId() : null;&#10;        if (currentUserId == null) {&#10;            if (callback != null) {&#10;                callback.onInitializationError(&quot;No hay usuario autenticado&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (hasDataLoaded()) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Datos ya están cargados - ejecutando callback inmediatamente&quot;);&#10;            if (callback != null) {&#10;                callback.onInitializationComplete();&#10;            }&#10;            return;&#10;        }&#10;&#10;        Log.d(&quot;GenerarData&quot;, &quot;No hay datos locales - cargando desde Firestore&quot;);&#10;        refreshDataForCurrentUser(callback);&#10;    }&#10;&#10;    public void loadFavorites(Context context) {&#10;    }&#10;&#10;    public void saveFavorites(Context context) {&#10;    }&#10;&#10;    public void onUserChanged(String newUserId) {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Usuario cambió a: &quot; + newUserId);&#10;&#10;        //LimpiarDatos&#10;        clearUserData();&#10;        dataChangeListeners.clear();&#10;&#10;        //cargarDatosNuevoUsuario&#10;        if (newUserId != null &amp;&amp; firestoreRepository != null) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Cargando datos para nuevo usuario: &quot; + newUserId);&#10;            loadDataFromFirestore();&#10;        } else {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Usuario deslogueado - manteniendo datos vacíos&quot;);&#10;            notifyDataChanged();&#10;        }&#10;    }&#10;    public void forceCompleteReinitialization(Context context) {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Forzando reinicialización completa del sistema&quot;);&#10;&#10;        clearUserData();&#10;        dataChangeListeners.clear();&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.cleanup();&#10;        }&#10;        firestoreRepository = new FirestoreRepository(context);&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        if (currentUserId != null) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Reinicializando para usuario: &quot; + currentUserId);&#10;            loadDataFromFirestore();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.models;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;public class GenerarData {&#10;    public interface DataChangeListener {&#10;        void onDataChanged();&#10;    }&#10;    public interface DataInitializationCallback {&#10;        void onInitializationComplete();&#10;        void onInitializationError(String error);&#10;    }&#10;    private static GenerarData instancia;&#10;    private FirestoreRepository firestoreRepository;&#10;    private List&lt;Note&gt; listaNotas;&#10;    private List&lt;Tag&gt; listaEtiquetas;&#10;    private List&lt;DataChangeListener&gt; dataChangeListeners;&#10;&#10;    private GenerarData() {&#10;        listaNotas = new ArrayList&lt;&gt;();&#10;        listaEtiquetas = new ArrayList&lt;&gt;();&#10;        dataChangeListeners = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    public static GenerarData getInstancia() {&#10;        if (instancia == null) {&#10;            instancia = new GenerarData();&#10;        }&#10;        return instancia;&#10;    }&#10;&#10;    public static GenerarData getInstance() {&#10;        return getInstancia();&#10;    }&#10;&#10;    //Metodos&#10;    public void addDataChangeListener(DataChangeListener listener) {&#10;        if (!dataChangeListeners.contains(listener)) {&#10;            dataChangeListeners.add(listener);&#10;        }&#10;    }&#10;    public void removeDataChangeListener(DataChangeListener listener) {&#10;        dataChangeListeners.remove(listener);&#10;    }&#10;    private void notifyDataChanged() {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Notificando cambio de datos a &quot; + dataChangeListeners.size() + &quot; listeners - Notas: &quot; + getListaNotas().size() + &quot;, Etiquetas: &quot; + getListaEtiquetas().size());&#10;        for (DataChangeListener listener : dataChangeListeners) {&#10;            listener.onDataChanged();&#10;        }&#10;    }&#10;    public void initializeWithContext(Context context) {&#10;        if (firestoreRepository == null) {&#10;            firestoreRepository = new FirestoreRepository(context);&#10;        }&#10;        loadDataFromFirestore(); //CargarDatos&#10;    }&#10;    private void loadDataFromFirestore() {&#10;        if (firestoreRepository == null) return;&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        Log.d(&quot;GenerarData&quot;, &quot;Cargando datos para usuario: &quot; + currentUserId);&#10;&#10;        // Usar getAllNotesIncludingTrash para obtener TODAS las notas (incluida papelera)&#10;        firestoreRepository.getAllNotesIncludingTrash(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                listaNotas = notes;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Notas cargadas exitosamente: &quot; + notes.size() + &quot; notas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaNotas = new ArrayList&lt;&gt;();&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando notas: &quot; + error);&#10;                notifyDataChanged();&#10;            }&#10;        });&#10;        &#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                listaEtiquetas = tags;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Etiquetas cargadas exitosamente: &quot; + tags.size() + &quot; etiquetas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaEtiquetas = new ArrayList&lt;&gt;();&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando etiquetas: &quot; + error);&#10;                notifyDataChanged();&#10;            }&#10;        });&#10;    }&#10;&#10;    public FirestoreRepository getFirestoreRepository() {&#10;        return firestoreRepository;&#10;    }&#10;&#10;    public List&lt;Note&gt; getListaNotas() {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaNotas;&#10;    }&#10;&#10;    public List&lt;Tag&gt; getListaEtiquetas() {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        return listaEtiquetas;&#10;    }&#10;&#10;    public void addNota(Note nota) {&#10;        if (listaNotas == null) {&#10;            listaNotas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaNotas.add(nota);&#10;        notifyDataChanged();&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveNote(nota, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Nota guardada exitosamente en Firestore&quot;);&#10;                }&#10;                @Override&#10;                public void onError(String error) {&#10;                    Log.e(&quot;GenerarData&quot;, &quot;Error guardando nota: &quot; + error);&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public void addTag(Tag tag) {&#10;        if (listaEtiquetas == null) {&#10;            listaEtiquetas = new ArrayList&lt;&gt;();&#10;        }&#10;        listaEtiquetas.add(tag);&#10;        notifyDataChanged();&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.saveTag(tag, new FirestoreRepository.SimpleCallback() {&#10;                @Override&#10;                public void onSuccess() {&#10;                    Log.d(&quot;GenerarData&quot;, &quot;Etiqueta guardada exitosamente en Firestore&quot;);&#10;                }&#10;                @Override&#10;                public void onError(String error) {&#10;                    Log.e(&quot;GenerarData&quot;, &quot;Error guardando etiqueta: &quot; + error);&#10;                }&#10;            });&#10;        }&#10;    }&#10;    public void clearUserData() {&#10;        if (listaNotas != null) {&#10;            listaNotas.clear();&#10;        }&#10;        if (listaEtiquetas != null) {&#10;            listaEtiquetas.clear();&#10;        }&#10;        notifyDataChanged();&#10;    }&#10;    public void forceReloadUserData() {&#10;        clearUserData();&#10;        loadDataFromFirestore();&#10;    }&#10;    public void refreshDataForCurrentUser() {&#10;        refreshDataForCurrentUser(null);&#10;    }&#10;    public void refreshDataForCurrentUser(DataInitializationCallback callback) {&#10;        String currentUserId = firestoreRepository != null ? firestoreRepository.getCurrentUserId() : null;&#10;        if (currentUserId != null) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Refrescando datos para usuario actual: &quot; + currentUserId);&#10;            clearUserData();&#10;            loadDataFromFirestoreWithCallback(callback);&#10;        } else {&#10;            Log.w(&quot;GenerarData&quot;, &quot;No hay usuario autenticado para refrescar datos&quot;);&#10;            if (callback != null) {&#10;                callback.onInitializationError(&quot;No hay usuario autenticado&quot;);&#10;            }&#10;        }&#10;    }&#10;    private void loadDataFromFirestoreWithCallback(DataInitializationCallback callback) {&#10;        if (firestoreRepository == null) {&#10;            if (callback != null) callback.onInitializationError(&quot;Repository not initialized&quot;);&#10;            return;&#10;        }&#10;&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        Log.d(&quot;GenerarData&quot;, &quot;Cargando datos con callback para usuario: &quot; + currentUserId);&#10;        final boolean[] notesLoaded = {false};&#10;        final boolean[] tagsLoaded = {false};&#10;        &#10;        // Usar getAllNotesIncludingTrash para obtener TODAS las notas (incluida papelera)&#10;        firestoreRepository.getAllNotesIncludingTrash(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; notes) {&#10;                listaNotas = notes;&#10;                notesLoaded[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Notas cargadas con callback: &quot; + notes.size() + &quot; notas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaNotas = new ArrayList&lt;&gt;();&#10;                notesLoaded[0] = true;&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando notas con callback: &quot; + error);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;        });&#10;&#10;        firestoreRepository.getAllTags(new FirestoreRepository.DataCallback&lt;List&lt;Tag&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Tag&gt; tags) {&#10;                listaEtiquetas = tags;&#10;                tagsLoaded[0] = true;&#10;                Log.d(&quot;GenerarData&quot;, &quot;Etiquetas cargadas con callback: &quot; + tags.size() + &quot; etiquetas para usuario &quot; + currentUserId);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;            @Override&#10;            public void onError(String error) {&#10;                listaEtiquetas = new ArrayList&lt;&gt;();&#10;                tagsLoaded[0] = true;&#10;                Log.e(&quot;GenerarData&quot;, &quot;Error cargando etiquetas con callback: &quot; + error);&#10;                notifyDataChanged();&#10;                checkCallbackCompletion(callback, notesLoaded, tagsLoaded);&#10;            }&#10;        });&#10;    }&#10;    private void checkCallbackCompletion(DataInitializationCallback callback, boolean[] notesLoaded, boolean[] tagsLoaded) {&#10;        if (callback != null &amp;&amp; notesLoaded[0] &amp;&amp; tagsLoaded[0]) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Datos completamente cargados - ejecutando callback&quot;);&#10;            notifyDataChanged();&#10;            callback.onInitializationComplete();&#10;        }&#10;    }&#10;    public void forceUpdateAllFragments() {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Forzando actualización de todos los fragmentos&quot;);&#10;        notifyDataChanged();&#10;    }&#10;&#10;    public boolean hasDataLoaded() {&#10;        return (listaNotas != null &amp;&amp; !listaNotas.isEmpty()) ||&#10;               (listaEtiquetas != null &amp;&amp; !listaEtiquetas.isEmpty());&#10;    }&#10;&#10;    public void ensureDataLoaded(DataInitializationCallback callback) {&#10;        String currentUserId = firestoreRepository != null ? firestoreRepository.getCurrentUserId() : null;&#10;        if (currentUserId == null) {&#10;            if (callback != null) {&#10;                callback.onInitializationError(&quot;No hay usuario autenticado&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (hasDataLoaded()) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Datos ya están cargados - ejecutando callback inmediatamente&quot;);&#10;            if (callback != null) {&#10;                callback.onInitializationComplete();&#10;            }&#10;            return;&#10;        }&#10;&#10;        Log.d(&quot;GenerarData&quot;, &quot;No hay datos locales - cargando desde Firestore&quot;);&#10;        refreshDataForCurrentUser(callback);&#10;    }&#10;&#10;    public void loadFavorites(Context context) {&#10;    }&#10;&#10;    public void saveFavorites(Context context) {&#10;    }&#10;&#10;    public void onUserChanged(String newUserId) {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Usuario cambió a: &quot; + newUserId);&#10;&#10;        //LimpiarDatos&#10;        clearUserData();&#10;        dataChangeListeners.clear();&#10;&#10;        //cargarDatosNuevoUsuario&#10;        if (newUserId != null &amp;&amp; firestoreRepository != null) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Cargando datos para nuevo usuario: &quot; + newUserId);&#10;            loadDataFromFirestore();&#10;        } else {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Usuario deslogueado - manteniendo datos vacíos&quot;);&#10;            notifyDataChanged();&#10;        }&#10;    }&#10;    public void forceCompleteReinitialization(Context context) {&#10;        Log.d(&quot;GenerarData&quot;, &quot;Forzando reinicialización completa del sistema&quot;);&#10;&#10;        clearUserData();&#10;        dataChangeListeners.clear();&#10;        if (firestoreRepository != null) {&#10;            firestoreRepository.cleanup();&#10;        }&#10;        firestoreRepository = new FirestoreRepository(context);&#10;        String currentUserId = firestoreRepository.getCurrentUserId();&#10;        if (currentUserId != null) {&#10;            Log.d(&quot;GenerarData&quot;, &quot;Reinicializando para usuario: &quot; + currentUserId);&#10;            loadDataFromFirestore();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java" />
              <option name="originalContent" value="package com.sgionotes.repository;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.GenerarData;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;public class FirestoreRepository {&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_USERS = &quot;users&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;    private String currentUserId = null;&#10;    private FirebaseAuth.AuthStateListener authStateListener; // NUEVO: Listener de cambios de autenticación&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;        setupAuthStateListener();&#10;    }&#10;    private void setupAuthStateListener() {&#10;        authStateListener = firebaseAuth -&gt; {&#10;            FirebaseUser user = firebaseAuth.getCurrentUser();&#10;            String newUserId = user != null ? user.getUid() : null;&#10;&#10;            if (!java.util.Objects.equals(currentUserId, newUserId)) {&#10;                Log.d(TAG, &quot;Usuario cambió de: &quot; + currentUserId + &quot; a: &quot; + newUserId);&#10;                currentUserId = newUserId;&#10;                if (context instanceof android.app.Activity) {&#10;                    ((android.app.Activity) context).runOnUiThread(() -&gt; {&#10;                        GenerarData.getInstancia().onUserChanged(currentUserId);&#10;                    });&#10;                }&#10;            }&#10;        };&#10;        mAuth.addAuthStateListener(authStateListener);&#10;    }&#10;    public String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        String userId = user != null ? user.getUid() : null;&#10;        if (!java.util.Objects.equals(currentUserId, userId)) {&#10;            Log.d(TAG, &quot;Usuario detectado como cambiado en getCurrentUserId(): &quot; + currentUserId + &quot; -&gt; &quot; + userId);&#10;            currentUserId = userId;&#10;        }&#10;        return userId;&#10;    }&#10;    //LimpiarRepsositorio&#10;    public void cleanup() {&#10;        if (authStateListener != null) {&#10;            mAuth.removeAuthStateListener(authStateListener);&#10;        }&#10;    }&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo tags para usuario: &quot; + userId);&#10;        //ConsultaBasica&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;                    tags.sort((t1, t2) -&gt; {&#10;                        if (t1.isFavorite() != t2.isFavorite()) {&#10;                            return Boolean.compare(t2.isFavorite(), t1.isFavorite());&#10;                        }&#10;                        return t1.getEtiquetaDescripcion().compareToIgnoreCase(t2.getEtiquetaDescripcion());&#10;                    });&#10;                    Log.d(TAG, &quot;Tags obtenidos exitosamente: &quot; + tags.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        if (tag.isFavorite()) {&#10;                            tags.add(tag);&#10;                        }&#10;                    }&#10;                    tags.sort((t1, t2) -&gt; Long.compare(t1.getFavoriteTimestamp(), t2.getFavoriteTimestamp()));&#10;&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        Log.d(TAG, &quot;Guardando tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    //Notas&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo notas para usuario: &quot; + userId);&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get(com.google.firebase.firestore.Source.SERVER) // Forzar datos del servidor&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;&#10;                        Log.d(TAG, &quot;Nota procesada: &quot; + note.getId() + &quot; isTrash: &quot; + note.isTrash());&#10;&#10;                        if (!note.isTrash()) {&#10;                            notes.add(note);&#10;                        }&#10;                    }&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    Log.d(TAG, &quot;Notas obtenidas exitosamente: &quot; + notes.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        //papelera&#10;                        if (note.isTrash()) {&#10;                            notes.add(note);&#10;                        }&#10;                    }&#10;                    //Orden&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        Log.d(TAG, &quot;Guardando nota para usuario: &quot; + userId);&#10;        note.setTimestamp(System.currentTimeMillis());&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            Log.d(TAG, &quot;Creando nueva nota en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            Log.d(TAG, &quot;Actualizando nota existente con ID: &quot; + note.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Actualizando estado de papelera para nota: &quot; + noteId + &quot; isTrash: &quot; + isTrash);&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado exitosamente&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.repository;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.GenerarData;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;public class FirestoreRepository {&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_USERS = &quot;users&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;    private String currentUserId = null;&#10;    private FirebaseAuth.AuthStateListener authStateListener; // NUEVO: Listener de cambios de autenticación&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;        setupAuthStateListener();&#10;    }&#10;    private void setupAuthStateListener() {&#10;        authStateListener = firebaseAuth -&gt; {&#10;            FirebaseUser user = firebaseAuth.getCurrentUser();&#10;            String newUserId = user != null ? user.getUid() : null;&#10;&#10;            if (!java.util.Objects.equals(currentUserId, newUserId)) {&#10;                Log.d(TAG, &quot;Usuario cambió de: &quot; + currentUserId + &quot; a: &quot; + newUserId);&#10;                currentUserId = newUserId;&#10;                if (context instanceof android.app.Activity) {&#10;                    ((android.app.Activity) context).runOnUiThread(() -&gt; {&#10;                        GenerarData.getInstancia().onUserChanged(currentUserId);&#10;                    });&#10;                }&#10;            }&#10;        };&#10;        mAuth.addAuthStateListener(authStateListener);&#10;    }&#10;    public String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        String userId = user != null ? user.getUid() : null;&#10;        if (!java.util.Objects.equals(currentUserId, userId)) {&#10;            Log.d(TAG, &quot;Usuario detectado como cambiado en getCurrentUserId(): &quot; + currentUserId + &quot; -&gt; &quot; + userId);&#10;            currentUserId = userId;&#10;        }&#10;        return userId;&#10;    }&#10;    //LimpiarRepsositorio&#10;    public void cleanup() {&#10;        if (authStateListener != null) {&#10;            mAuth.removeAuthStateListener(authStateListener);&#10;        }&#10;    }&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo tags para usuario: &quot; + userId);&#10;        //ConsultaBasica&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;                    tags.sort((t1, t2) -&gt; {&#10;                        if (t1.isFavorite() != t2.isFavorite()) {&#10;                            return Boolean.compare(t2.isFavorite(), t1.isFavorite());&#10;                        }&#10;                        return t1.getEtiquetaDescripcion().compareToIgnoreCase(t2.getEtiquetaDescripcion());&#10;                    });&#10;                    Log.d(TAG, &quot;Tags obtenidos exitosamente: &quot; + tags.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        if (tag.isFavorite()) {&#10;                            tags.add(tag);&#10;                        }&#10;                    }&#10;                    tags.sort((t1, t2) -&gt; Long.compare(t1.getFavoriteTimestamp(), t2.getFavoriteTimestamp()));&#10;&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        Log.d(TAG, &quot;Guardando tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    //Notas&#10;    // Método para obtener TODAS las notas (incluyendo papelera) - usado por GenerarData&#10;    public void getAllNotesIncludingTrash(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo todas las notas (incluida papelera) para usuario: &quot; + userId);&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get(com.google.firebase.firestore.Source.SERVER)&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        Log.d(TAG, &quot;Nota procesada: &quot; + note.getId() + &quot; isTrash: &quot; + note.isTrash());&#10;                        notes.add(note); // Agregar todas las notas sin filtrar&#10;                    }&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    Log.d(TAG, &quot;Todas las notas obtenidas exitosamente: &quot; + notes.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo todas las notas para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    // Método para obtener solo las notas activas (sin papelera) - usado por fragmentos específicos&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        getAllNotesIncludingTrash(new DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Note&gt; allNotes) {&#10;                List&lt;Note&gt; activeNotes = new ArrayList&lt;&gt;();&#10;                for (Note note : allNotes) {&#10;                    if (!note.isTrash()) {&#10;                        activeNotes.add(note);&#10;                    }&#10;                }&#10;                callback.onSuccess(activeNotes);&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                callback.onError(error);&#10;            }&#10;        });&#10;    }&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        //papelera&#10;                        if (note.isTrash()) {&#10;                            notes.add(note);&#10;                        }&#10;                    }&#10;                    //Orden&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;        Log.d(TAG, &quot;Guardando nota para usuario: &quot; + userId);&#10;        note.setTimestamp(System.currentTimeMillis());&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            Log.d(TAG, &quot;Creando nueva nota en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            Log.d(TAG, &quot;Actualizando nota existente con ID: &quot; + note.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Actualizando estado de papelera para nota: &quot; + noteId + &quot; isTrash: &quot; + isTrash);&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado exitosamente&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>