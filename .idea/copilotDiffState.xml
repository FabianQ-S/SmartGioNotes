<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java" />
              <option name="originalContent" value="package com.sgionotes.repository;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.GenerarData;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class FirestoreRepository {&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_USERS = &quot;users&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;    private String currentUserId = null; // CRÍTICO: Cache del usuario actual&#10;    private FirebaseAuth.AuthStateListener authStateListener; // NUEVO: Listener de cambios de autenticación&#10;&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;&#10;        // CRÍTICO: Implementar AuthStateListener según documentación oficial&#10;        setupAuthStateListener();&#10;    }&#10;&#10;    // NUEVO: Configurar listener de cambios de autenticación&#10;    private void setupAuthStateListener() {&#10;        authStateListener = firebaseAuth -&gt; {&#10;            FirebaseUser user = firebaseAuth.getCurrentUser();&#10;            String newUserId = user != null ? user.getUid() : null;&#10;&#10;            if (!java.util.Objects.equals(currentUserId, newUserId)) {&#10;                Log.d(TAG, &quot;Usuario cambió de: &quot; + currentUserId + &quot; a: &quot; + newUserId);&#10;                currentUserId = newUserId;&#10;&#10;                // CRÍTICO: Notificar cambio de usuario a GenerarData&#10;                if (context instanceof android.app.Activity) {&#10;                    ((android.app.Activity) context).runOnUiThread(() -&gt; {&#10;                        GenerarData.getInstancia().onUserChanged(currentUserId);&#10;                    });&#10;                }&#10;            }&#10;        };&#10;        mAuth.addAuthStateListener(authStateListener);&#10;    }&#10;&#10;    // CRÍTICO: Método mejorado para obtener usuario actual&#10;    public String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        String userId = user != null ? user.getUid() : null;&#10;&#10;        // Verificar si el usuario cambió&#10;        if (!java.util.Objects.equals(currentUserId, userId)) {&#10;            Log.d(TAG, &quot;Usuario detectado como cambiado en getCurrentUserId(): &quot; + currentUserId + &quot; -&gt; &quot; + userId);&#10;            currentUserId = userId;&#10;        }&#10;&#10;        return userId;&#10;    }&#10;&#10;    // NUEVO: Método para limpiar el repository cuando se destruye&#10;    public void cleanup() {&#10;        if (authStateListener != null) {&#10;            mAuth.removeAuthStateListener(authStateListener);&#10;        }&#10;    }&#10;&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo tags para usuario: &quot; + userId);&#10;        // SIMPLIFICADO: Solo una consulta básica sin índices complejos&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;&#10;                    // NUEVO: Ordenar en memoria en lugar de en la consulta&#10;                    tags.sort((t1, t2) -&gt; {&#10;                        // Primero por favoritos (favoritos primero)&#10;                        if (t1.isFavorite() != t2.isFavorite()) {&#10;                            return Boolean.compare(t2.isFavorite(), t1.isFavorite());&#10;                        }&#10;                        // Luego por descripción alfabéticamente&#10;                        return t1.getEtiquetaDescripcion().compareToIgnoreCase(t2.getEtiquetaDescripcion());&#10;                    });&#10;&#10;                    Log.d(TAG, &quot;Tags obtenidos exitosamente: &quot; + tags.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        // SIMPLIFICADO: Obtener todos los tags y filtrar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;&#10;                        // Filtrar solo favoritos&#10;                        if (tag.isFavorite()) {&#10;                            tags.add(tag);&#10;                        }&#10;                    }&#10;&#10;                    // Ordenar por timestamp de favorito&#10;                    tags.sort((t1, t2) -&gt; Long.compare(t1.getFavoriteTimestamp(), t2.getFavoriteTimestamp()));&#10;&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            // Nueva Etiqueta&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Etiqueta&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    //Notas&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo notas para usuario: &quot; + userId);&#10;        // OPTIMIZADO: Consulta completa con índices (restaurada)&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;isTrash&quot;, false)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    Log.d(TAG, &quot;Notas obtenidas exitosamente: &quot; + notes.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;isTrash&quot;, true)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando nota para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;        note.setTimestamp(System.currentTimeMillis());&#10;&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            // Crear Nota&#10;            Log.d(TAG, &quot;Creando nueva nota en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Nota&#10;            Log.d(TAG, &quot;Actualizando nota existente con ID: &quot; + note.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.repository;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.GenerarData;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class FirestoreRepository {&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_USERS = &quot;users&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;    private String currentUserId = null; // CRÍTICO: Cache del usuario actual&#10;    private FirebaseAuth.AuthStateListener authStateListener; // NUEVO: Listener de cambios de autenticación&#10;&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;&#10;        // CRÍTICO: Implementar AuthStateListener según documentación oficial&#10;        setupAuthStateListener();&#10;    }&#10;&#10;    // NUEVO: Configurar listener de cambios de autenticación&#10;    private void setupAuthStateListener() {&#10;        authStateListener = firebaseAuth -&gt; {&#10;            FirebaseUser user = firebaseAuth.getCurrentUser();&#10;            String newUserId = user != null ? user.getUid() : null;&#10;&#10;            if (!java.util.Objects.equals(currentUserId, newUserId)) {&#10;                Log.d(TAG, &quot;Usuario cambió de: &quot; + currentUserId + &quot; a: &quot; + newUserId);&#10;                currentUserId = newUserId;&#10;&#10;                // CRÍTICO: Notificar cambio de usuario a GenerarData&#10;                if (context instanceof android.app.Activity) {&#10;                    ((android.app.Activity) context).runOnUiThread(() -&gt; {&#10;                        GenerarData.getInstancia().onUserChanged(currentUserId);&#10;                    });&#10;                }&#10;            }&#10;        };&#10;        mAuth.addAuthStateListener(authStateListener);&#10;    }&#10;&#10;    // CRÍTICO: Método mejorado para obtener usuario actual&#10;    public String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        String userId = user != null ? user.getUid() : null;&#10;&#10;        // Verificar si el usuario cambió&#10;        if (!java.util.Objects.equals(currentUserId, userId)) {&#10;            Log.d(TAG, &quot;Usuario detectado como cambiado en getCurrentUserId(): &quot; + currentUserId + &quot; -&gt; &quot; + userId);&#10;            currentUserId = userId;&#10;        }&#10;&#10;        return userId;&#10;    }&#10;&#10;    // NUEVO: Método para limpiar el repository cuando se destruye&#10;    public void cleanup() {&#10;        if (authStateListener != null) {&#10;            mAuth.removeAuthStateListener(authStateListener);&#10;        }&#10;    }&#10;&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo tags para usuario: &quot; + userId);&#10;        // SIMPLIFICADO: Solo una consulta básica sin índices complejos&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;&#10;                    // NUEVO: Ordenar en memoria en lugar de en la consulta&#10;                    tags.sort((t1, t2) -&gt; {&#10;                        // Primero por favoritos (favoritos primero)&#10;                        if (t1.isFavorite() != t2.isFavorite()) {&#10;                            return Boolean.compare(t2.isFavorite(), t1.isFavorite());&#10;                        }&#10;                        // Luego por descripción alfabéticamente&#10;                        return t1.getEtiquetaDescripcion().compareToIgnoreCase(t2.getEtiquetaDescripcion());&#10;                    });&#10;&#10;                    Log.d(TAG, &quot;Tags obtenidos exitosamente: &quot; + tags.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        // SIMPLIFICADO: Obtener todos los tags y filtrar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;&#10;                        // Filtrar solo favoritos&#10;                        if (tag.isFavorite()) {&#10;                            tags.add(tag);&#10;                        }&#10;                    }&#10;&#10;                    // Ordenar por timestamp de favorito&#10;                    tags.sort((t1, t2) -&gt; Long.compare(t1.getFavoriteTimestamp(), t2.getFavoriteTimestamp()));&#10;&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            // Nueva Etiqueta&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Etiqueta&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    //Notas&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo notas para usuario: &quot; + userId);&#10;        // SIMPLIFICADO: Solo obtener todas las notas y filtrar/ordenar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        &#10;                        // Filtrar solo notas que no están en papelera&#10;                        if (!note.isTrash()) {&#10;                            notes.add(note);&#10;                        }&#10;                    }&#10;                    &#10;                    // Ordenar por timestamp en memoria (más recientes primero)&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    &#10;                    Log.d(TAG, &quot;Notas obtenidas exitosamente: &quot; + notes.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        // SIMPLIFICADO: Obtener todas las notas y filtrar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        &#10;                        // Filtrar solo notas en papelera&#10;                        if (note.isTrash()) {&#10;                            notes.add(note);&#10;                        }&#10;                    }&#10;                    &#10;                    // Ordenar por timestamp en memoria (más recientes primero)&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    &#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando nota para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;        note.setTimestamp(System.currentTimeMillis());&#10;&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            // Crear Nota&#10;            Log.d(TAG, &quot;Creando nueva nota en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Nota&#10;            Log.d(TAG, &quot;Actualizando nota existente con ID: &quot; + note.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>