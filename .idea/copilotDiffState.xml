<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/activities/MainActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/activities/MainActivity.java" />
              <option name="originalContent" value="package com.sgionotes.activities;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.util.Log;&#10;import android.view.View;&#10;import android.widget.ImageView;&#10;import android.widget.TextView;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.ActionBarDrawerToggle;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.widget.Toolbar;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.GravityCompat;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;import androidx.drawerlayout.widget.DrawerLayout;&#10;import androidx.fragment.app.Fragment;&#10;import com.google.android.material.navigation.NavigationView;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.sgionotes.R;&#10;import com.sgionotes.dialogs.ProfileIconDialog;&#10;import com.sgionotes.fragments.NoteFragment;&#10;import com.sgionotes.fragments.NotePrivateFragment;&#10;import com.sgionotes.fragments.TagFragment;&#10;import com.sgionotes.fragments.TrashFragment;&#10;import com.sgionotes.models.GenerarData;&#10;import com.sgionotes.models.UserProfile;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import com.sgionotes.utils.UserProfileManager;&#10;import java.util.Objects;&#10;import java.util.List;&#10;public class MainActivity extends AppCompatActivity {&#10;    private DrawerLayout drawerLayout;&#10;    private NavigationView navigationView;&#10;    private ActionBarDrawerToggle toggle;&#10;    private FirebaseAuth mAuth;&#10;    private FirestoreRepository firestoreRepository;&#10;    private Handler saveHandler;&#10;    private Runnable saveRunnable;&#10;    private NoteFragment notes = new NoteFragment();&#10;    private TagFragment tags = new TagFragment();&#10;    private TrashFragment trash = new TrashFragment();&#10;    private NotePrivateFragment tagsPrivate = new NotePrivateFragment();&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        mAuth = FirebaseAuth.getInstance();&#10;&#10;        if (mAuth.getCurrentUser() == null) {&#10;            // Si no hay usuario autenticado, redirigir al login&#10;            Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;            return;&#10;        }&#10;        firestoreRepository = new FirestoreRepository(this);&#10;        setupToolbarAndNavigation();&#10;&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        generarData.clearUserData();&#10;        generarData.initializeWithContext(this);&#10;&#10;        loadFragment(notes);&#10;        setupUserProfile();&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main_content), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;    private void setupToolbarAndNavigation() {&#10;        Toolbar toolbar = findViewById(R.id.toolbar);&#10;        setSupportActionBar(toolbar);&#10;        Objects.requireNonNull(getSupportActionBar()).setDisplayShowTitleEnabled(false);&#10;        drawerLayout = findViewById(R.id.drawer_layout);&#10;        navigationView = findViewById(R.id.nav_view);&#10;        toggle = new ActionBarDrawerToggle(&#10;                this, drawerLayout, toolbar,&#10;                R.string.navigation_drawer_open,&#10;                R.string.navigation_drawer_close&#10;        );&#10;        drawerLayout.addDrawerListener(toggle);&#10;        toggle.syncState();&#10;        navigationView.setNavigationItemSelectedListener(item -&gt; {&#10;            int id = item.getItemId();&#10;            drawerLayout.closeDrawer(GravityCompat.START);&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                if (id == R.id.notes) {&#10;                    loadFragment(notes);&#10;                } else if (id == R.id.tags) {&#10;                    loadFragment(tags);&#10;                } else if (id == R.id.trash) {&#10;                    loadFragment(trash);&#10;                } else if (id == R.id.btnLogout) {&#10;                    logoutUser();&#10;                }&#10;            }, 300);&#10;            return true;&#10;        });&#10;    }&#10;    private void setupAutoSave() {&#10;    }&#10;    private void saveUserDataToFirestore(Runnable onComplete) {&#10;        if (onComplete != null) {&#10;            onComplete.run();&#10;        }&#10;    }&#10;    private void saveUserDataToFirestore() {&#10;        // Método mantenido para compatibilidad&#10;    }&#10;    private void logoutUser() {&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        if (generarData.getFirestoreRepository() != null) {&#10;            Log.d(&quot;MainActivity&quot;, &quot;Guardando datos antes del logout...&quot;);&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                generarData.clearUserData();&#10;                mAuth.signOut();&#10;                Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;                startActivity(intent);&#10;                finish();&#10;            }, 1000); //FirestoreCarga&#10;        } else {&#10;            mAuth.signOut();&#10;            Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;        }&#10;    }&#10;    public void loadFragment(Fragment fragment) {&#10;        getSupportFragmentManager()&#10;                .beginTransaction()&#10;                .replace(R.id.contenedor, fragment)&#10;                .commit();&#10;    }&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        Log.d(&quot;MainActivity&quot;, &quot;App pausada - forzando guardado de datos&quot;);&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        if (generarData.getFirestoreRepository() != null) {&#10;            generarData.getFirestoreRepository().getAllNotes(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;                @Override&#10;                public void onSuccess(List&lt;Note&gt; notes) {&#10;                }&#10;                @Override&#10;                public void onError(String error) {&#10;                }&#10;            });&#10;        }&#10;    }&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        Log.d(&quot;MainActivity&quot;, &quot;MainActivity destruida - limpiando recursos&quot;);&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        if (generarData.getFirestoreRepository() != null) {&#10;            generarData.getFirestoreRepository().cleanup();&#10;        }&#10;        if (saveHandler != null &amp;&amp; saveRunnable != null) {&#10;            saveHandler.removeCallbacks(saveRunnable);&#10;        }&#10;    }&#10;    private void setupUserProfile() {&#10;        View headerView = navigationView.getHeaderView(0);&#10;        ImageView imgProfileIcon = headerView.findViewById(R.id.imgProfileIcon);&#10;        ImageView imgEditIcon = headerView.findViewById(R.id.imgEditIcon);&#10;        TextView txtUserName = headerView.findViewById(R.id.txtUserName);&#10;        TextView txtUserEmail = headerView.findViewById(R.id.txtUserEmail);&#10;&#10;        updateUserProfileDisplay(imgProfileIcon, txtUserName, txtUserEmail);&#10;&#10;        imgProfileIcon.setOnClickListener(v -&gt; {&#10;            imgEditIcon.setVisibility(View.VISIBLE);&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                imgEditIcon.setVisibility(View.GONE);&#10;            }, 2000);&#10;        });&#10;&#10;        imgEditIcon.setOnClickListener(v -&gt; showProfileIconDialog(imgProfileIcon, txtUserName, txtUserEmail));&#10;        headerView.findViewById(R.id.cardProfileIcon).setOnClickListener(v -&gt;&#10;                showProfileIconDialog(imgProfileIcon, txtUserName, txtUserEmail));&#10;    }&#10;&#10;    private void updateUserProfileDisplay(ImageView imgProfileIcon, TextView txtUserName, TextView txtUserEmail) {&#10;        UserProfileManager profileManager = new UserProfileManager(this);&#10;        UserProfile profile = profileManager.getUserProfile();&#10;&#10;        imgProfileIcon.setImageResource(profile.getProfileIcon());&#10;        txtUserName.setText(profile.getFullName());&#10;        txtUserEmail.setText(profile.getEmail());&#10;    }&#10;&#10;    private void loadUserProfile(ImageView imgProfileIcon, TextView txtUserName, TextView txtUserEmail) {&#10;        updateUserProfileDisplay(imgProfileIcon, txtUserName, txtUserEmail);&#10;    }&#10;&#10;    private void showProfileIconDialog(ImageView imgProfileIcon, TextView txtUserName, TextView txtUserEmail) {&#10;        ProfileIconDialog.showIconSelectionDialog(this, selectedIcon -&gt; {&#10;            UserProfileManager profileManager = new UserProfileManager(this);&#10;            UserProfile profile = profileManager.getUserProfile();&#10;            profile.setProfileIcon(selectedIcon);&#10;            profileManager.saveUserProfile(profile);&#10;            imgProfileIcon.setImageResource(selectedIcon);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        Log.d(&quot;MainActivity&quot;, &quot;MainActivity resumida - verificando datos del usuario&quot;);&#10;        FirebaseUser currentUser = mAuth.getCurrentUser();&#10;        if (currentUser != null) {&#10;            GenerarData generarData = GenerarData.getInstancia();&#10;            Log.d(&quot;MainActivity&quot;, &quot;Forzando reinicialización completa en onResume para usuario: &quot; + currentUser.getUid());&#10;            generarData.forceCompleteReinitialization(this);&#10;&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                if (notes != null) {&#10;                    generarData.addDataChangeListener(notes);&#10;                }&#10;                if (tags != null) {&#10;                    generarData.addDataChangeListener(tags);&#10;                }&#10;                generarData.forceUpdateAllFragments();&#10;            }, 1000);&#10;&#10;        } else {&#10;            Log.w(&quot;MainActivity&quot;, &quot;No hay usuario autenticado en onResume - redirigiendo al login&quot;);&#10;            Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.activities;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.util.Log;&#10;import android.view.View;&#10;import android.widget.ImageView;&#10;import android.widget.TextView;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.ActionBarDrawerToggle;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.widget.Toolbar;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.GravityCompat;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;import androidx.drawerlayout.widget.DrawerLayout;&#10;import androidx.fragment.app.Fragment;&#10;import com.google.android.material.navigation.NavigationView;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.sgionotes.R;&#10;import com.sgionotes.dialogs.ProfileIconDialog;&#10;import com.sgionotes.fragments.NoteFragment;&#10;import com.sgionotes.fragments.NotePrivateFragment;&#10;import com.sgionotes.fragments.TagFragment;&#10;import com.sgionotes.fragments.TrashFragment;&#10;import com.sgionotes.models.GenerarData;&#10;import com.sgionotes.models.UserProfile;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.repository.FirestoreRepository;&#10;import com.sgionotes.utils.UserProfileManager;&#10;import java.util.Objects;&#10;import java.util.List;&#10;public class MainActivity extends AppCompatActivity {&#10;    private DrawerLayout drawerLayout;&#10;    private NavigationView navigationView;&#10;    private ActionBarDrawerToggle toggle;&#10;    private FirebaseAuth mAuth;&#10;    private FirestoreRepository firestoreRepository;&#10;    private Handler saveHandler;&#10;    private Runnable saveRunnable;&#10;    private NoteFragment notes = new NoteFragment();&#10;    private TagFragment tags = new TagFragment();&#10;    private TrashFragment trash = new TrashFragment();&#10;    private NotePrivateFragment tagsPrivate = new NotePrivateFragment();&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        mAuth = FirebaseAuth.getInstance();&#10;&#10;        if (mAuth.getCurrentUser() == null) {&#10;            // Si no hay usuario autenticado, redirigir al login&#10;            Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;            return;&#10;        }&#10;        firestoreRepository = new FirestoreRepository(this);&#10;        setupToolbarAndNavigation();&#10;&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        generarData.clearUserData();&#10;        generarData.initializeWithContext(this);&#10;&#10;        loadFragment(notes);&#10;        setupUserProfile();&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main_content), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;    private void setupToolbarAndNavigation() {&#10;        Toolbar toolbar = findViewById(R.id.toolbar);&#10;        setSupportActionBar(toolbar);&#10;        Objects.requireNonNull(getSupportActionBar()).setDisplayShowTitleEnabled(false);&#10;        drawerLayout = findViewById(R.id.drawer_layout);&#10;        navigationView = findViewById(R.id.nav_view);&#10;        toggle = new ActionBarDrawerToggle(&#10;                this, drawerLayout, toolbar,&#10;                R.string.navigation_drawer_open,&#10;                R.string.navigation_drawer_close&#10;        );&#10;        drawerLayout.addDrawerListener(toggle);&#10;        toggle.syncState();&#10;        navigationView.setNavigationItemSelectedListener(item -&gt; {&#10;            int id = item.getItemId();&#10;            drawerLayout.closeDrawer(GravityCompat.START);&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                if (id == R.id.notes) {&#10;                    loadFragment(notes);&#10;                } else if (id == R.id.tags) {&#10;                    loadFragment(tags);&#10;                } else if (id == R.id.trash) {&#10;                    loadFragment(trash);&#10;                } else if (id == R.id.btnLogout) {&#10;                    logoutUser();&#10;                }&#10;            }, 300);&#10;            return true;&#10;        });&#10;    }&#10;    private void setupAutoSave() {&#10;    }&#10;    private void saveUserDataToFirestore(Runnable onComplete) {&#10;        if (onComplete != null) {&#10;            onComplete.run();&#10;        }&#10;    }&#10;    private void saveUserDataToFirestore() {&#10;        // Método mantenido para compatibilidad&#10;    }&#10;    private void logoutUser() {&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        if (generarData.getFirestoreRepository() != null) {&#10;            Log.d(&quot;MainActivity&quot;, &quot;Guardando datos antes del logout...&quot;);&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                generarData.clearUserData();&#10;                mAuth.signOut();&#10;                Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;                startActivity(intent);&#10;                finish();&#10;            }, 1000); //FirestoreCarga&#10;        } else {&#10;            mAuth.signOut();&#10;            Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;        }&#10;    }&#10;    public void loadFragment(Fragment fragment) {&#10;        getSupportFragmentManager()&#10;                .beginTransaction()&#10;                .replace(R.id.contenedor, fragment)&#10;                .commit();&#10;    }&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        Log.d(&quot;MainActivity&quot;, &quot;App pausada - forzando guardado de datos&quot;);&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        if (generarData.getFirestoreRepository() != null) {&#10;            generarData.getFirestoreRepository().getAllNotes(new FirestoreRepository.DataCallback&lt;List&lt;Note&gt;&gt;() {&#10;                @Override&#10;                public void onSuccess(List&lt;Note&gt; notes) {&#10;                }&#10;                @Override&#10;                public void onError(String error) {&#10;                }&#10;            });&#10;        }&#10;    }&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        Log.d(&quot;MainActivity&quot;, &quot;MainActivity destruida - limpiando recursos&quot;);&#10;        GenerarData generarData = GenerarData.getInstancia();&#10;        if (generarData.getFirestoreRepository() != null) {&#10;            generarData.getFirestoreRepository().cleanup();&#10;        }&#10;        if (saveHandler != null &amp;&amp; saveRunnable != null) {&#10;            saveHandler.removeCallbacks(saveRunnable);&#10;        }&#10;    }&#10;    private void setupUserProfile() {&#10;        View headerView = navigationView.getHeaderView(0);&#10;        ImageView imgProfileIcon = headerView.findViewById(R.id.imgProfileIcon);&#10;        ImageView imgEditIcon = headerView.findViewById(R.id.imgEditIcon);&#10;        TextView txtUserName = headerView.findViewById(R.id.txtUserName);&#10;        TextView txtUserEmail = headerView.findViewById(R.id.txtUserEmail);&#10;&#10;        updateUserProfileDisplay(imgProfileIcon, txtUserName, txtUserEmail);&#10;&#10;        imgProfileIcon.setOnClickListener(v -&gt; {&#10;            imgEditIcon.setVisibility(View.VISIBLE);&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                imgEditIcon.setVisibility(View.GONE);&#10;            }, 2000);&#10;        });&#10;&#10;        imgEditIcon.setOnClickListener(v -&gt; showProfileIconDialog(imgProfileIcon, txtUserName, txtUserEmail));&#10;        headerView.findViewById(R.id.cardProfileIcon).setOnClickListener(v -&gt;&#10;                showProfileIconDialog(imgProfileIcon, txtUserName, txtUserEmail));&#10;    }&#10;&#10;    private void updateUserProfileDisplay(ImageView imgProfileIcon, TextView txtUserName, TextView txtUserEmail) {&#10;        UserProfileManager profileManager = new UserProfileManager(this);&#10;        UserProfile profile = profileManager.getUserProfile();&#10;&#10;        imgProfileIcon.setImageResource(profile.getProfileIcon());&#10;        txtUserName.setText(profile.getFullName());&#10;        txtUserEmail.setText(profile.getEmail());&#10;    }&#10;&#10;    private void loadUserProfile(ImageView imgProfileIcon, TextView txtUserName, TextView txtUserEmail) {&#10;        updateUserProfileDisplay(imgProfileIcon, txtUserName, txtUserEmail);&#10;    }&#10;&#10;    private void showProfileIconDialog(ImageView imgProfileIcon, TextView txtUserName, TextView txtUserEmail) {&#10;        ProfileIconDialog.showIconSelectionDialog(this, selectedIcon -&gt; {&#10;            UserProfileManager profileManager = new UserProfileManager(this);&#10;            UserProfile profile = profileManager.getUserProfile();&#10;            profile.setProfileIcon(selectedIcon);&#10;            profileManager.saveUserProfile(profile);&#10;            imgProfileIcon.setImageResource(selectedIcon);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        Log.d(&quot;MainActivity&quot;, &quot;MainActivity resumida - verificando datos del usuario&quot;);&#10;        FirebaseUser currentUser = mAuth.getCurrentUser();&#10;        if (currentUser != null) {&#10;            View headerView = navigationView.getHeaderView(0);&#10;            ImageView imgProfileIcon = headerView.findViewById(R.id.imgProfileIcon);&#10;            TextView txtUserName = headerView.findViewById(R.id.txtUserName);&#10;            TextView txtUserEmail = headerView.findViewById(R.id.txtUserEmail);&#10;            updateUserProfileDisplay(imgProfileIcon, txtUserName, txtUserEmail);&#10;            &#10;            GenerarData generarData = GenerarData.getInstancia();&#10;            Log.d(&quot;MainActivity&quot;, &quot;Forzando reinicialización completa en onResume para usuario: &quot; + currentUser.getUid());&#10;            generarData.forceCompleteReinitialization(this);&#10;&#10;            new Handler(Looper.getMainLooper()).postDelayed(() -&gt; {&#10;                if (notes != null) {&#10;                    generarData.addDataChangeListener(notes);&#10;                }&#10;                if (tags != null) {&#10;                    generarData.addDataChangeListener(tags);&#10;                }&#10;                generarData.forceUpdateAllFragments();&#10;            }, 1000);&#10;&#10;        } else {&#10;            Log.w(&quot;MainActivity&quot;, &quot;No hay usuario autenticado en onResume - redirigiendo al login&quot;);&#10;            Intent intent = new Intent(MainActivity.this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/dialogs/ProfileIconDialog.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/dialogs/ProfileIconDialog.java" />
              <option name="originalContent" value="package com.sgionotes.dialogs;&#10;&#10;import android.app.Dialog;&#10;import android.content.Context;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.ImageView;&#10;import androidx.annotation.NonNull;&#10;import androidx.recyclerview.widget.GridLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder;&#10;import com.sgionotes.R;&#10;import com.sgionotes.utils.UserProfileManager;&#10;&#10;public class ProfileIconDialog {&#10;&#10;    public interface OnIconSelectedListener {&#10;        void onIconSelected(int iconResId);&#10;    }&#10;&#10;    public static void showIconSelectionDialog(Context context, OnIconSelectedListener listener) {&#10;        try {&#10;            View dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_profile_icons, null);&#10;&#10;            RecyclerView recyclerView = dialogView.findViewById(R.id.recyclerProfileIcons);&#10;            GridLayoutManager gridLayoutManager = new GridLayoutManager(context, 3);&#10;            recyclerView.setLayoutManager(gridLayoutManager);&#10;            recyclerView.setHasFixedSize(true);&#10;&#10;            Dialog dialog = new MaterialAlertDialogBuilder(context)&#10;                    .setView(dialogView)&#10;                    .setNegativeButton(&quot;Cancelar&quot;, null)&#10;                    .create();&#10;&#10;            IconAdapter adapter = new IconAdapter(UserProfileManager.PROFILE_ICONS, (iconResId) -&gt; {&#10;                if (listener != null) {&#10;                    listener.onIconSelected(iconResId);&#10;                }&#10;                dialog.dismiss();&#10;            });&#10;&#10;            recyclerView.setAdapter(adapter);&#10;            dialog.show();&#10;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static class IconAdapter extends RecyclerView.Adapter&lt;IconAdapter.IconViewHolder&gt; {&#10;&#10;        private final int[] icons;&#10;        private final OnIconSelectedListener listener;&#10;&#10;        public IconAdapter(int[] icons, OnIconSelectedListener listener) {&#10;            this.icons = icons;&#10;            this.listener = listener;&#10;        }&#10;&#10;        @NonNull&#10;        @Override&#10;        public IconViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;            View view = LayoutInflater.from(parent.getContext())&#10;                    .inflate(R.layout.item_profile_icon, parent, false);&#10;            return new IconViewHolder(view);&#10;        }&#10;&#10;        @Override&#10;        public void onBindViewHolder(@NonNull IconViewHolder holder, int position) {&#10;            int iconResId = icons[position];&#10;            holder.imageView.setImageResource(iconResId);&#10;&#10;            holder.itemView.setOnClickListener(v -&gt; {&#10;                if (listener != null) {&#10;                    listener.onIconSelected(iconResId);&#10;                }&#10;            });&#10;        }&#10;&#10;        @Override&#10;        public int getItemCount() {&#10;            return icons.length;&#10;        }&#10;&#10;        static class IconViewHolder extends RecyclerView.ViewHolder {&#10;            ImageView imageView;&#10;&#10;            IconViewHolder(@NonNull View itemView) {&#10;                super(itemView);&#10;                imageView = itemView.findViewById(R.id.imgProfileIcon);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.dialogs;&#10;&#10;import android.app.Dialog;&#10;import android.content.Context;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.ImageView;&#10;import androidx.annotation.NonNull;&#10;import androidx.recyclerview.widget.GridLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import com.google.android.material.dialog.MaterialAlertDialogBuilder;&#10;import com.sgionotes.R;&#10;import com.sgionotes.utils.UserProfileManager;&#10;&#10;public class ProfileIconDialog {&#10;&#10;    public interface OnIconSelectedListener {&#10;        void onIconSelected(int iconResId);&#10;    }&#10;&#10;    public static void showIconSelectionDialog(Context context, OnIconSelectedListener listener) {&#10;        try {&#10;            View dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_profile_icons, null);&#10;&#10;            RecyclerView recyclerView = dialogView.findViewById(R.id.recyclerProfileIcons);&#10;            GridLayoutManager gridLayoutManager = new GridLayoutManager(context, 2);&#10;            recyclerView.setLayoutManager(gridLayoutManager);&#10;            recyclerView.setHasFixedSize(true);&#10;&#10;            Dialog dialog = new MaterialAlertDialogBuilder(context)&#10;                    .setView(dialogView)&#10;                    .setNegativeButton(&quot;Cancelar&quot;, null)&#10;                    .create();&#10;&#10;            IconAdapter adapter = new IconAdapter(UserProfileManager.PROFILE_ICONS, (iconResId) -&gt; {&#10;                if (listener != null) {&#10;                    listener.onIconSelected(iconResId);&#10;                }&#10;                dialog.dismiss();&#10;            });&#10;&#10;            recyclerView.setAdapter(adapter);&#10;            dialog.show();&#10;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static class IconAdapter extends RecyclerView.Adapter&lt;IconAdapter.IconViewHolder&gt; {&#10;&#10;        private final int[] icons;&#10;        private final OnIconSelectedListener listener;&#10;&#10;        public IconAdapter(int[] icons, OnIconSelectedListener listener) {&#10;            this.icons = icons;&#10;            this.listener = listener;&#10;        }&#10;&#10;        @NonNull&#10;        @Override&#10;        public IconViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;            View view = LayoutInflater.from(parent.getContext())&#10;                    .inflate(R.layout.item_profile_icon, parent, false);&#10;            return new IconViewHolder(view);&#10;        }&#10;&#10;        @Override&#10;        public void onBindViewHolder(@NonNull IconViewHolder holder, int position) {&#10;            int iconResId = icons[position];&#10;            holder.imageView.setImageResource(iconResId);&#10;&#10;            holder.itemView.setOnClickListener(v -&gt; {&#10;                if (listener != null) {&#10;                    listener.onIconSelected(iconResId);&#10;                }&#10;            });&#10;        }&#10;&#10;        @Override&#10;        public int getItemCount() {&#10;            return icons.length;&#10;        }&#10;&#10;        static class IconViewHolder extends RecyclerView.ViewHolder {&#10;            ImageView imageView;&#10;&#10;            IconViewHolder(@NonNull View itemView) {&#10;                super(itemView);&#10;                imageView = itemView.findViewById(R.id.imgProfileIcon);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/repository/FirestoreRepository.java" />
              <option name="originalContent" value="package com.sgionotes.repository;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.GenerarData;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class FirestoreRepository {&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_USERS = &quot;users&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;    private String currentUserId = null; // CRÍTICO: Cache del usuario actual&#10;    private FirebaseAuth.AuthStateListener authStateListener; // NUEVO: Listener de cambios de autenticación&#10;&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;&#10;        // CRÍTICO: Implementar AuthStateListener según documentación oficial&#10;        setupAuthStateListener();&#10;    }&#10;&#10;    // NUEVO: Configurar listener de cambios de autenticación&#10;    private void setupAuthStateListener() {&#10;        authStateListener = firebaseAuth -&gt; {&#10;            FirebaseUser user = firebaseAuth.getCurrentUser();&#10;            String newUserId = user != null ? user.getUid() : null;&#10;&#10;            if (!java.util.Objects.equals(currentUserId, newUserId)) {&#10;                Log.d(TAG, &quot;Usuario cambió de: &quot; + currentUserId + &quot; a: &quot; + newUserId);&#10;                currentUserId = newUserId;&#10;&#10;                // CRÍTICO: Notificar cambio de usuario a GenerarData&#10;                if (context instanceof android.app.Activity) {&#10;                    ((android.app.Activity) context).runOnUiThread(() -&gt; {&#10;                        GenerarData.getInstancia().onUserChanged(currentUserId);&#10;                    });&#10;                }&#10;            }&#10;        };&#10;        mAuth.addAuthStateListener(authStateListener);&#10;    }&#10;&#10;    // CRÍTICO: Método mejorado para obtener usuario actual&#10;    public String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        String userId = user != null ? user.getUid() : null;&#10;&#10;        // Verificar si el usuario cambió&#10;        if (!java.util.Objects.equals(currentUserId, userId)) {&#10;            Log.d(TAG, &quot;Usuario detectado como cambiado en getCurrentUserId(): &quot; + currentUserId + &quot; -&gt; &quot; + userId);&#10;            currentUserId = userId;&#10;        }&#10;&#10;        return userId;&#10;    }&#10;&#10;    // NUEVO: Método para limpiar el repository cuando se destruye&#10;    public void cleanup() {&#10;        if (authStateListener != null) {&#10;            mAuth.removeAuthStateListener(authStateListener);&#10;        }&#10;    }&#10;&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo tags para usuario: &quot; + userId);&#10;        // SIMPLIFICADO: Solo una consulta básica sin índices complejos&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;&#10;                    // NUEVO: Ordenar en memoria en lugar de en la consulta&#10;                    tags.sort((t1, t2) -&gt; {&#10;                        // Primero por favoritos (favoritos primero)&#10;                        if (t1.isFavorite() != t2.isFavorite()) {&#10;                            return Boolean.compare(t2.isFavorite(), t1.isFavorite());&#10;                        }&#10;                        // Luego por descripción alfabéticamente&#10;                        return t1.getEtiquetaDescripcion().compareToIgnoreCase(t2.getEtiquetaDescripcion());&#10;                    });&#10;&#10;                    Log.d(TAG, &quot;Tags obtenidos exitosamente: &quot; + tags.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        // SIMPLIFICADO: Obtener todos los tags y filtrar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;&#10;                        // Filtrar solo favoritos&#10;                        if (tag.isFavorite()) {&#10;                            tags.add(tag);&#10;                        }&#10;                    }&#10;&#10;                    // Ordenar por timestamp de favorito&#10;                    tags.sort((t1, t2) -&gt; Long.compare(t1.getFavoriteTimestamp(), t2.getFavoriteTimestamp()));&#10;&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            // Nueva Etiqueta&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Etiqueta&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    //Notas&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo notas para usuario: &quot; + userId);&#10;        // OPTIMIZADO: Consulta completa con índices (restaurada)&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;isTrash&quot;, false)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    Log.d(TAG, &quot;Notas obtenidas exitosamente: &quot; + notes.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .whereEqualTo(&quot;isTrash&quot;, true)&#10;                .orderBy(&quot;timestamp&quot;, Query.Direction.DESCENDING)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        notes.add(note);&#10;                    }&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando nota para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;        note.setTimestamp(System.currentTimeMillis());&#10;&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            // Crear Nota&#10;            Log.d(TAG, &quot;Creando nueva nota en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Nota&#10;            Log.d(TAG, &quot;Actualizando nota existente con ID: &quot; + note.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.repository;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.google.firebase.firestore.DocumentSnapshot;&#10;import com.google.firebase.firestore.FirebaseFirestore;&#10;import com.google.firebase.firestore.FirebaseFirestoreSettings;&#10;import com.google.firebase.firestore.Query;&#10;import com.google.firebase.firestore.QueryDocumentSnapshot;&#10;import com.sgionotes.models.Note;&#10;import com.sgionotes.models.Tag;&#10;import com.sgionotes.models.GenerarData;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class FirestoreRepository {&#10;    private static final String TAG = &quot;FirestoreRepository&quot;;&#10;    private static final String COLLECTION_USERS = &quot;users&quot;;&#10;    private static final String COLLECTION_NOTES = &quot;notes&quot;;&#10;    private static final String COLLECTION_TAGS = &quot;tags&quot;;&#10;    private final FirebaseFirestore db;&#10;    private final FirebaseAuth mAuth;&#10;    private Context context;&#10;    private String currentUserId = null; // CRÍTICO: Cache del usuario actual&#10;    private FirebaseAuth.AuthStateListener authStateListener; // NUEVO: Listener de cambios de autenticación&#10;&#10;    public FirestoreRepository(Context context) {&#10;        db = FirebaseFirestore.getInstance();&#10;        FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()&#10;                .setPersistenceEnabled(true)&#10;                .build();&#10;        db.setFirestoreSettings(settings);&#10;        mAuth = FirebaseAuth.getInstance();&#10;        this.context = context;&#10;&#10;        // CRÍTICO: Implementar AuthStateListener según documentación oficial&#10;        setupAuthStateListener();&#10;    }&#10;&#10;    // NUEVO: Configurar listener de cambios de autenticación&#10;    private void setupAuthStateListener() {&#10;        authStateListener = firebaseAuth -&gt; {&#10;            FirebaseUser user = firebaseAuth.getCurrentUser();&#10;            String newUserId = user != null ? user.getUid() : null;&#10;&#10;            if (!java.util.Objects.equals(currentUserId, newUserId)) {&#10;                Log.d(TAG, &quot;Usuario cambió de: &quot; + currentUserId + &quot; a: &quot; + newUserId);&#10;                currentUserId = newUserId;&#10;&#10;                // CRÍTICO: Notificar cambio de usuario a GenerarData&#10;                if (context instanceof android.app.Activity) {&#10;                    ((android.app.Activity) context).runOnUiThread(() -&gt; {&#10;                        GenerarData.getInstancia().onUserChanged(currentUserId);&#10;                    });&#10;                }&#10;            }&#10;        };&#10;        mAuth.addAuthStateListener(authStateListener);&#10;    }&#10;&#10;    // CRÍTICO: Método mejorado para obtener usuario actual&#10;    public String getCurrentUserId() {&#10;        FirebaseUser user = mAuth.getCurrentUser();&#10;        String userId = user != null ? user.getUid() : null;&#10;&#10;        // Verificar si el usuario cambió&#10;        if (!java.util.Objects.equals(currentUserId, userId)) {&#10;            Log.d(TAG, &quot;Usuario detectado como cambiado en getCurrentUserId(): &quot; + currentUserId + &quot; -&gt; &quot; + userId);&#10;            currentUserId = userId;&#10;        }&#10;&#10;        return userId;&#10;    }&#10;&#10;    // NUEVO: Método para limpiar el repository cuando se destruye&#10;    public void cleanup() {&#10;        if (authStateListener != null) {&#10;            mAuth.removeAuthStateListener(authStateListener);&#10;        }&#10;    }&#10;&#10;    public interface DataCallback&lt;T&gt; {&#10;        void onSuccess(T data);&#10;        void onError(String error);&#10;    }&#10;    public interface SimpleCallback {&#10;        void onSuccess();&#10;        void onError(String error);&#10;    }&#10;    public void getAllTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo tags para usuario: &quot; + userId);&#10;        // SIMPLIFICADO: Solo una consulta básica sin índices complejos&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;                        tags.add(tag);&#10;                    }&#10;&#10;                    // NUEVO: Ordenar en memoria en lugar de en la consulta&#10;                    tags.sort((t1, t2) -&gt; {&#10;                        // Primero por favoritos (favoritos primero)&#10;                        if (t1.isFavorite() != t2.isFavorite()) {&#10;                            return Boolean.compare(t2.isFavorite(), t1.isFavorite());&#10;                        }&#10;                        // Luego por descripción alfabéticamente&#10;                        return t1.getEtiquetaDescripcion().compareToIgnoreCase(t2.getEtiquetaDescripcion());&#10;                    });&#10;&#10;                    Log.d(TAG, &quot;Tags obtenidos exitosamente: &quot; + tags.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getFavoriteTags(DataCallback&lt;List&lt;Tag&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        // SIMPLIFICADO: Obtener todos los tags y filtrar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Tag tag = document.toObject(Tag.class);&#10;                        tag.setId(document.getId());&#10;&#10;                        // Filtrar solo favoritos&#10;                        if (tag.isFavorite()) {&#10;                            tags.add(tag);&#10;                        }&#10;                    }&#10;&#10;                    // Ordenar por timestamp de favorito&#10;                    tags.sort((t1, t2) -&gt; Long.compare(t1.getFavoriteTimestamp(), t2.getFavoriteTimestamp()));&#10;&#10;                    callback.onSuccess(tags);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tags favoritos&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiquetas favoritas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveTag(Tag tag, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            Log.e(TAG, &quot;Error: Usuario no autenticado&quot;);&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando tag: &quot; + tag.getEtiquetaDescripcion() + &quot; para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;&#10;        if (tag.getId() == null || tag.getId().isEmpty()) {&#10;            // Nueva Etiqueta&#10;            Log.d(TAG, &quot;Creando nueva etiqueta en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .add(tag)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        tag.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Tag creado exitosamente con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al crear etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Etiqueta&#10;            Log.d(TAG, &quot;Actualizando etiqueta existente con ID: &quot; + tag.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_TAGS)&#10;                    .document(tag.getId())&#10;                    .set(tag)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Tag actualizado exitosamente&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando tag en Firestore&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar etiqueta: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteTag(String tagId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Tag eliminado&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando tag&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setTagFavorite(String tagId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || tagId == null || tagId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de etiqueta inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_TAGS)&#10;                .document(tagId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Tag tag = documentSnapshot.toObject(Tag.class);&#10;                        if (tag != null) {&#10;                            tag.setId(documentSnapshot.getId());&#10;                            tag.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_TAGS)&#10;                                    .document(tagId)&#10;                                    .set(tag)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Tag favorito actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la etiqueta&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Etiqueta no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo tag&quot;, e);&#10;                    callback.onError(&quot;Error al obtener etiqueta: &quot; + e.getMessage());&#10;                });&#10;    }&#10;    //Notas&#10;    public void getAllNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Obteniendo notas para usuario: &quot; + userId);&#10;        // SIMPLIFICADO: Solo obtener todas las notas y filtrar/ordenar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        &#10;                        // Filtrar solo notas que no están en papelera&#10;                        if (!note.isTrash()) {&#10;                            notes.add(note);&#10;                        }&#10;                    }&#10;                    &#10;                    // Ordenar por timestamp en memoria (más recientes primero)&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    &#10;                    Log.d(TAG, &quot;Notas obtenidas exitosamente: &quot; + notes.size() + &quot; para usuario: &quot; + userId);&#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas para usuario: &quot; + userId, e);&#10;                    callback.onError(&quot;Error al obtener notas: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void getTrashNotes(DataCallback&lt;List&lt;Note&gt;&gt; callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        // SIMPLIFICADO: Obtener todas las notas y filtrar en memoria&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .get()&#10;                .addOnSuccessListener(queryDocumentSnapshots -&gt; {&#10;                    List&lt;Note&gt; notes = new ArrayList&lt;&gt;();&#10;                    for (QueryDocumentSnapshot document : queryDocumentSnapshots) {&#10;                        Note note = document.toObject(Note.class);&#10;                        note.setId(document.getId());&#10;                        &#10;                        // Filtrar solo notas en papelera&#10;                        if (note.isTrash()) {&#10;                            notes.add(note);&#10;                        }&#10;                    }&#10;                    &#10;                    // Ordenar por timestamp en memoria (más recientes primero)&#10;                    notes.sort((n1, n2) -&gt; Long.compare(n2.getTimestamp(), n1.getTimestamp()));&#10;                    &#10;                    callback.onSuccess(notes);&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo notas de papelera&quot;, e);&#10;                    callback.onError(&quot;Error al obtener notas de papelera: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void saveNote(Note note, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null) {&#10;            callback.onError(&quot;Usuario no autenticado&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.d(TAG, &quot;Guardando nota para usuario: &quot; + userId);&#10;        // Ya no necesitamos setUserId porque está en la estructura jerárquica&#10;        note.setTimestamp(System.currentTimeMillis());&#10;&#10;        if (note.getId() == null || note.getId().isEmpty()) {&#10;            // Crear Nota&#10;            Log.d(TAG, &quot;Creando nueva nota en Firestore&quot;);&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .add(note)&#10;                    .addOnSuccessListener(documentReference -&gt; {&#10;                        note.setId(documentReference.getId());&#10;                        Log.d(TAG, &quot;Nota creada con ID: &quot; + documentReference.getId());&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error creando nota&quot;, e);&#10;                        callback.onError(&quot;Error al crear nota: &quot; + e.getMessage());&#10;                    });&#10;        } else {&#10;            // Actualizar Nota&#10;            Log.d(TAG, &quot;Actualizando nota existente con ID: &quot; + note.getId());&#10;            db.collection(COLLECTION_USERS)&#10;                    .document(userId)&#10;                    .collection(COLLECTION_NOTES)&#10;                    .document(note.getId())&#10;                    .set(note)&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Nota actualizada&quot;);&#10;                        callback.onSuccess();&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error actualizando nota&quot;, e);&#10;                        callback.onError(&quot;Error al actualizar nota: &quot; + e.getMessage());&#10;                    });&#10;        }&#10;    }&#10;&#10;    public void deleteNotePermanently(String noteId, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .delete()&#10;                .addOnSuccessListener(aVoid -&gt; {&#10;                    Log.d(TAG, &quot;Nota eliminada permanentemente&quot;);&#10;                    callback.onSuccess();&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error eliminando nota permanentemente&quot;, e);&#10;                    callback.onError(&quot;Error al eliminar nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void moveNoteToTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, true, callback);&#10;    }&#10;&#10;    public void restoreNoteFromTrash(String noteId, SimpleCallback callback) {&#10;        updateNoteTrashStatus(noteId, false, callback);&#10;    }&#10;&#10;    private void updateNoteTrashStatus(String noteId, boolean isTrash, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setTrash(isTrash);&#10;                            note.setTimestamp(System.currentTimeMillis());&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Estado de papelera actualizado&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando estado de papelera&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar estado: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;&#10;    public void setNoteFavorite(String noteId, boolean isFavorite, SimpleCallback callback) {&#10;        String userId = getCurrentUserId();&#10;        if (userId == null || noteId == null || noteId.isEmpty()) {&#10;            callback.onError(&quot;Usuario no autenticado o ID de nota inválido&quot;);&#10;            return;&#10;        }&#10;&#10;        db.collection(COLLECTION_USERS)&#10;                .document(userId)&#10;                .collection(COLLECTION_NOTES)&#10;                .document(noteId)&#10;                .get()&#10;                .addOnSuccessListener(documentSnapshot -&gt; {&#10;                    if (documentSnapshot.exists()) {&#10;                        Note note = documentSnapshot.toObject(Note.class);&#10;                        if (note != null) {&#10;                            note.setId(documentSnapshot.getId());&#10;                            note.setFavorite(isFavorite);&#10;&#10;                            db.collection(COLLECTION_USERS)&#10;                                    .document(userId)&#10;                                    .collection(COLLECTION_NOTES)&#10;                                    .document(noteId)&#10;                                    .set(note)&#10;                                    .addOnSuccessListener(aVoid -&gt; {&#10;                                        Log.d(TAG, &quot;Nota favorita actualizada&quot;);&#10;                                        callback.onSuccess();&#10;                                    })&#10;                                    .addOnFailureListener(e -&gt; {&#10;                                        Log.e(TAG, &quot;Error actualizando favorito de nota&quot;, e);&#10;                                        callback.onError(&quot;Error al actualizar favorito: &quot; + e.getMessage());&#10;                                    });&#10;                        } else {&#10;                            callback.onError(&quot;Error al obtener datos de la nota&quot;);&#10;                        }&#10;                    } else {&#10;                        callback.onError(&quot;Nota no encontrada&quot;);&#10;                    }&#10;                })&#10;                .addOnFailureListener(e -&gt; {&#10;                    Log.e(TAG, &quot;Error obteniendo nota&quot;, e);&#10;                    callback.onError(&quot;Error al obtener nota: &quot; + e.getMessage());&#10;                });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sgionotes/utils/UserProfileManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sgionotes/utils/UserProfileManager.java" />
              <option name="originalContent" value="package com.sgionotes.utils;&#10;&#10;import android.content.Context;&#10;import android.content.SharedPreferences;&#10;import com.sgionotes.R;&#10;import com.sgionotes.models.UserProfile;&#10;&#10;public class UserProfileManager {&#10;&#10;    private static final String PREFS_NAME = &quot;user_profile&quot;;&#10;    private static final String KEY_NOMBRES = &quot;nombres&quot;;&#10;    private static final String KEY_APELLIDOS = &quot;apellidos&quot;;&#10;    private static final String KEY_EMAIL = &quot;email&quot;;&#10;    private static final String KEY_PROFILE_ICON = &quot;profile_icon&quot;;&#10;&#10;    private SharedPreferences prefs;&#10;    private SharedPreferences.Editor editor;&#10;&#10;    //MaterialIcons&#10;    public static final int[] PROFILE_ICONS = {&#10;        R.drawable.ic_person_24,&#10;        R.drawable.ic_school_24,&#10;        R.drawable.ic_group_24,&#10;        R.drawable.ic_pets_24,&#10;        R.drawable.ic_event_note_24,&#10;        R.drawable.ic_artist_24,&#10;        R.drawable.ic_nature_24,&#10;        R.drawable.ic_my_location_24,&#10;        R.drawable.ic_motorcycle_24&#10;    };&#10;&#10;    public UserProfileManager(Context context) {&#10;        prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);&#10;        editor = prefs.edit();&#10;    }&#10;&#10;    public void saveUserProfile(UserProfile profile) {&#10;        editor.putString(KEY_NOMBRES, profile.getNombres());&#10;        editor.putString(KEY_APELLIDOS, profile.getApellidos());&#10;        editor.putString(KEY_EMAIL, profile.getEmail());&#10;        editor.putInt(KEY_PROFILE_ICON, profile.getProfileIcon());&#10;        editor.apply();&#10;    }&#10;&#10;    public UserProfile getUserProfile() {&#10;        String nombres = prefs.getString(KEY_NOMBRES, &quot;Usuario&quot;);&#10;        String apellidos = prefs.getString(KEY_APELLIDOS, &quot;&quot;);&#10;        String email = prefs.getString(KEY_EMAIL, &quot;&quot;);&#10;        int profileIcon = prefs.getInt(KEY_PROFILE_ICON, R.drawable.outline_account_circle_24);&#10;&#10;        return new UserProfile(nombres, apellidos, email, profileIcon);&#10;    }&#10;&#10;    public void clearUserProfile() {&#10;        editor.clear();&#10;        editor.apply();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sgionotes.utils;&#10;&#10;import android.content.Context;&#10;import android.content.SharedPreferences;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.sgionotes.R;&#10;import com.sgionotes.models.UserProfile;&#10;&#10;public class UserProfileManager {&#10;&#10;    private static final String PREFS_PREFIX = &quot;user_profile_&quot;;&#10;    private static final String KEY_NOMBRES = &quot;nombres&quot;;&#10;    private static final String KEY_APELLIDOS = &quot;apellidos&quot;;&#10;    private static final String KEY_EMAIL = &quot;email&quot;;&#10;    private static final String KEY_PROFILE_ICON = &quot;profile_icon&quot;;&#10;&#10;    private SharedPreferences prefs;&#10;    private SharedPreferences.Editor editor;&#10;    private Context context;&#10;&#10;    //MaterialIcons&#10;    public static final int[] PROFILE_ICONS = {&#10;        R.drawable.ic_person_24,&#10;        R.drawable.ic_school_24,&#10;        R.drawable.ic_group_24,&#10;        R.drawable.ic_pets_24,&#10;        R.drawable.ic_event_note_24,&#10;        R.drawable.ic_artist_24,&#10;        R.drawable.ic_nature_24,&#10;        R.drawable.ic_my_location_24,&#10;        R.drawable.ic_motorcycle_24&#10;    };&#10;&#10;    public UserProfileManager(Context context) {&#10;        this.context = context;&#10;        initializePrefs();&#10;    }&#10;&#10;    private void initializePrefs() {&#10;        FirebaseUser currentUser = FirebaseAuth.getInstance().getCurrentUser();&#10;        String userId = currentUser != null ? currentUser.getUid() : &quot;default&quot;;&#10;        String prefsName = PREFS_PREFIX + userId;&#10;        &#10;        prefs = context.getSharedPreferences(prefsName, Context.MODE_PRIVATE);&#10;        editor = prefs.edit();&#10;    }&#10;&#10;    public void saveUserProfile(UserProfile profile) {&#10;        initializePrefs();&#10;        editor.putString(KEY_NOMBRES, profile.getNombres());&#10;        editor.putString(KEY_APELLIDOS, profile.getApellidos());&#10;        editor.putString(KEY_EMAIL, profile.getEmail());&#10;        editor.putInt(KEY_PROFILE_ICON, profile.getProfileIcon());&#10;        editor.apply();&#10;    }&#10;&#10;    public UserProfile getUserProfile() {&#10;        initializePrefs();&#10;        &#10;        FirebaseUser currentUser = FirebaseAuth.getInstance().getCurrentUser();&#10;        String defaultEmail = currentUser != null ? (currentUser.getEmail() != null ? currentUser.getEmail() : &quot;&quot;) : &quot;&quot;;&#10;        &#10;        String nombres = prefs.getString(KEY_NOMBRES, &quot;Usuario&quot;);&#10;        String apellidos = prefs.getString(KEY_APELLIDOS, &quot;&quot;);&#10;        String email = prefs.getString(KEY_EMAIL, defaultEmail);&#10;        int profileIcon = prefs.getInt(KEY_PROFILE_ICON, R.drawable.outline_account_circle_24);&#10;&#10;        if (email.isEmpty() &amp;&amp; currentUser != null &amp;&amp; currentUser.getEmail() != null) {&#10;            email = currentUser.getEmail();&#10;            UserProfile profile = new UserProfile(nombres, apellidos, email, profileIcon);&#10;            saveUserProfile(profile);&#10;        }&#10;&#10;        return new UserProfile(nombres, apellidos, email, profileIcon);&#10;    }&#10;&#10;    public void clearUserProfile() {&#10;        initializePrefs();&#10;        editor.clear();&#10;        editor.apply();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_pets_24.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_pets_24.xml" />
              <option name="originalContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M12,8.5c2.5,0 4.5,2 4.5,4.5s-2,4.5-4.5,4.5 -4.5,-2 -4.5,-4.5 2,-4.5 4.5,-4.5zM8.5,6c1,0 1.8,0.8 1.8,1.8s-0.8,1.8 -1.8,1.8 -1.8,-0.8 -1.8,-1.8 0.8,-1.8 1.8,-1.8zM15.5,6c1,0 1.8,0.8 1.8,1.8s-0.8,1.8 -1.8,1.8 -1.8,-0.8 -1.8,-1.8 0.8,-1.8 1.8,-1.8zM9.5,4c0.8,0 1.5,0.7 1.5,1.5s-0.7,1.5 -1.5,1.5 -1.5,-0.7 -1.5,-1.5 0.7,-1.5 1.5,-1.5zM14.5,4c0.8,0 1.5,0.7 1.5,1.5s-0.7,1.5 -1.5,1.5 -1.5,-0.7 -1.5,-1.5 0.7,-1.5 1.5,-1.5z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M12,16c1.66,0 3,-1.34 3,-3s-1.34,-3 -3,-3 -3,1.34 -3,3 1.34,3 3,3zM8.5,7.5c0.83,0 1.5,0.67 1.5,1.5s-0.67,1.5 -1.5,1.5S7,9.83 7,9s0.67,-1.5 1.5,-1.5zM15.5,7.5c0.83,0 1.5,0.67 1.5,1.5s-0.67,1.5 -1.5,1.5S14,9.83 14,9s0.67,-1.5 1.5,-1.5zM10,5c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM14,5c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_profile_icons.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_profile_icons.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:gravity=&quot;center&quot;&#10;    android:padding=&quot;24dp&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/recyclerProfileIcons&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        android:overScrollMode=&quot;never&quot;&#10;        android:clipToPadding=&quot;false&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:gravity=&quot;center&quot;&#10;    android:padding=&quot;24dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Selecciona tu icono de perfil&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginBottom=&quot;24dp&quot;&#10;        android:textColor=&quot;?android:attr/textColorPrimary&quot; /&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/recyclerProfileIcons&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        android:overScrollMode=&quot;never&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:padding=&quot;8dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_profile_icon.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_profile_icon.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.cardview.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;80dp&quot;&#10;    android:layout_height=&quot;80dp&quot;&#10;    android:layout_margin=&quot;8dp&quot;&#10;    android:layout_gravity=&quot;center&quot;&#10;    app:cardCornerRadius=&quot;40dp&quot;&#10;    app:cardElevation=&quot;6dp&quot;&#10;    app:cardBackgroundColor=&quot;@color/primary&quot;&#10;    android:clickable=&quot;true&quot;&#10;    android:focusable=&quot;true&quot;&#10;    android:foreground=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&gt;&#10;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/imgProfileIcon&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        android:scaleType=&quot;centerInside&quot;&#10;        android:padding=&quot;3dp&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        app:tint=&quot;@android:color/white&quot;&#10;        android:alpha=&quot;1.0&quot; /&gt;&#10;&#10;&lt;/androidx.cardview.widget.CardView&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;0dp&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:layout_weight=&quot;1&quot;&#10;    android:gravity=&quot;center&quot;&#10;    android:padding=&quot;4dp&quot;&gt;&#10;&#10;    &lt;androidx.cardview.widget.CardView&#10;        android:layout_width=&quot;72dp&quot;&#10;        android:layout_height=&quot;72dp&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        app:cardCornerRadius=&quot;36dp&quot;&#10;        app:cardElevation=&quot;6dp&quot;&#10;        app:cardBackgroundColor=&quot;@color/primary&quot;&#10;        android:clickable=&quot;true&quot;&#10;        android:focusable=&quot;true&quot;&#10;        android:foreground=&quot;?android:attr/selectableItemBackgroundBorderless&quot;&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/imgProfileIcon&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;match_parent&quot;&#10;            android:scaleType=&quot;centerInside&quot;&#10;            android:padding=&quot;8dp&quot;&#10;            android:layout_gravity=&quot;center&quot;&#10;            app:tint=&quot;@android:color/white&quot;&#10;            android:alpha=&quot;1.0&quot; /&gt;&#10;&#10;    &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>